;;; All the macros and the scheme-object printing procedure
;;; are defined in compiler.s
%include "compiler.s"

section .bss
;;; This pointer is used to manage allocations on our heap.
malloc_pointer:
    resq 1

;;; here we REServe enough Quad-words (64-bit "cells") for the free variables
;;; each free variable has 8 bytes reserved for a 64-bit pointer to its value
fvar_tbl:
    resq 51

section .data
const_tbl:
db T_VOID
db T_NIL
db T_BOOL, 0
db T_BOOL, 1
MAKE_LITERAL_STRING 119,104,97,116,101,118,101,114
MAKE_LITERAL_SYMBOL(const_tbl+6)
MAKE_LITERAL_RATIONAL(1,1)
MAKE_LITERAL_CHAR(0)
MAKE_LITERAL_RATIONAL(0,1)
MAKE_LITERAL_RATIONAL(-1,1)
MAKE_LITERAL_RATIONAL(5,1)
MAKE_LITERAL_CHAR(32)
MAKE_LITERAL_CHAR(116)
MAKE_LITERAL_CHAR(9)
MAKE_LITERAL_RATIONAL(3,1)
MAKE_LITERAL_CHAR(110)
MAKE_LITERAL_RATIONAL(4,1)
MAKE_LITERAL_CHAR(10)

;;; These macro definitions are required for the primitive
;;; definitions in the epilogue to work properly
%define SOB_VOID_ADDRESS const_tbl+0
%define SOB_NIL_ADDRESS const_tbl+1
%define SOB_FALSE_ADDRESS const_tbl+2
%define SOB_TRUE_ADDRESS const_tbl+4

global main
section .text
main:
    ;; set up the heap
    mov rdi, GB(2)
    call malloc
    mov [malloc_pointer], rax

    ;; Set up the dummy activation frame
    ;; The dummy return address is T_UNDEFINED
    ;; (which a is a macro for 0) so that returning
    ;; from the top level (which SHOULD NOT HAPPEN
    ;; AND IS A BUG) will cause a segfault.
    push 0                ; argument count
    push SOB_NIL_ADDRESS  ; lexical environment address
    push T_UNDEFINED      ; return address
    push rbp                    
    mov rbp, rsp                ; anchor the dummy frame

    ;; Set up the primitive stdlib fvars:
    ;; Since the primtive procedures are defined in assembly,
    ;; they are not generated by scheme (define ...) expressions.
    ;; This is where we simulate the missing (define ...) expressions
    ;; for all the primitive procedures.
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, boolean?)
mov [fvar_tbl+ 8*0], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, flonum?)
mov [fvar_tbl+ 8*1], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, rational?)
mov [fvar_tbl+ 8*2], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, pair?)
mov [fvar_tbl+ 8*3], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, null?)
mov [fvar_tbl+ 8*4], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, char?)
mov [fvar_tbl+ 8*5], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string?)
mov [fvar_tbl+ 8*6], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, procedure?)
mov [fvar_tbl+ 8*7], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, symbol?)
mov [fvar_tbl+ 8*8], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_length)
mov [fvar_tbl+ 8*9], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_ref)
mov [fvar_tbl+ 8*10], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_set)
mov [fvar_tbl+ 8*11], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, make_string)
mov [fvar_tbl+ 8*12], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, symbol_to_string)
mov [fvar_tbl+ 8*13], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, char_to_integer)
mov [fvar_tbl+ 8*14], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, integer_to_char)
mov [fvar_tbl+ 8*15], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, exact_to_inexact)
mov [fvar_tbl+ 8*16], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, eq?)
mov [fvar_tbl+ 8*17], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, add)
mov [fvar_tbl+ 8*18], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, mul)
mov [fvar_tbl+ 8*19], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, div)
mov [fvar_tbl+ 8*20], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, eq)
mov [fvar_tbl+ 8*21], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, lt)
mov [fvar_tbl+ 8*22], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, numerator)
mov [fvar_tbl+ 8*23], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, denominator)
mov [fvar_tbl+ 8*24], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, gcd)
mov [fvar_tbl+ 8*25], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, car)
mov [fvar_tbl+ 8*26], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, cdr)
mov [fvar_tbl+ 8*27], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, cons)
mov [fvar_tbl+ 8*28], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, setcar)
mov [fvar_tbl+ 8*30], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, setcdr)
mov [fvar_tbl+ 8*31], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, apply)
mov [fvar_tbl+ 8*29], rax

user_code_fragment:
;;; The code you compiled will be added here.
;;; It will be executed immediately after the closures for 
;;; the primitive procedures are set up.
; Applic

mov rax, qword [fvar_tbl + 8*29]

 push rax 
mov rax, qword [fvar_tbl + 8*28]

 push rax 
mov rax, qword [fvar_tbl + 8*27]

 push rax 
mov rax, qword [fvar_tbl + 8*26]

 push rax 
mov rax, qword [fvar_tbl + 8*4]

 push rax 

 push 5
; LambdaSimple

MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode1)
jmp Lcont1
Lcode1:
push rbp
mov rbp, rsp


mov rax, const_tbl + 23

 push rax 

mov rax, const_tbl + 23

 push rax 

 push 2
; LambdaSimple

MALLOC rbx, 16 ; rbx = pointer to ExtEnv
mov qword r8, [rbp + 8*2] ; r8 is a pointer to lexical env
; rbx[i+1] <- r8[i] using r9
mov rcx, 0 ; rcx is the loop var
mov rdx, 1
simple_ext_loop2:
mov r9, qword [r8 + 8*rcx]
mov qword [rbx + 8*(rcx+1)], r9
inc rcx
cmp rcx, rdx
jne simple_ext_loop2
mov r10, qword [rbp + 8 * 3] ; r10 is the number of params in previous env
mov r11, r10 ; save the amount of params
shl r10, 3 ; r10 = r10 * 8 - the real size that we should save
MALLOC rdx, r10
mov rcx, 0 ; rcx is the loop var, r11 is the limit, doing the exchange using r14
cmp r11, 0 ; there is no parameters
je simple_param_end_loop2
simple_param_loop2:
mov r14, PVAR(rcx)
mov qword [rdx + 8*(rcx)], r14
inc rcx
cmp rcx, r11
jne simple_param_loop2
simple_param_end_loop2:
mov qword [rbx], rdx ; put this env in ExtEnv[0]
MAKE_CLOSURE(rax, rbx, Lcode2)
jmp Lcont2
Lcode2:
push rbp
mov rbp, rsp



mov rax, qword [rbp + 8 * (4 + 0)]

MALLOC r8, 8
mov qword[r8], rax
mov rax, r8

mov qword [rbp + 8 * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS


mov rax, qword [rbp + 8 * (4 + 1)]

MALLOC r8, 8
mov qword[r8], rax
mov rax, r8

mov qword [rbp + 8 * (4 + 1)], rax
mov rax, SOB_VOID_ADDRESS

; LambdaSimple

MALLOC rbx, 24 ; rbx = pointer to ExtEnv
mov qword r8, [rbp + 8*2] ; r8 is a pointer to lexical env
; rbx[i+1] <- r8[i] using r9
mov rcx, 0 ; rcx is the loop var
mov rdx, 2
simple_ext_loop3:
mov r9, qword [r8 + 8*rcx]
mov qword [rbx + 8*(rcx+1)], r9
inc rcx
cmp rcx, rdx
jne simple_ext_loop3
mov r10, qword [rbp + 8 * 3] ; r10 is the number of params in previous env
mov r11, r10 ; save the amount of params
shl r10, 3 ; r10 = r10 * 8 - the real size that we should save
MALLOC rdx, r10
mov rcx, 0 ; rcx is the loop var, r11 is the limit, doing the exchange using r14
cmp r11, 0 ; there is no parameters
je simple_param_end_loop3
simple_param_loop3:
mov r14, PVAR(rcx)
mov qword [rdx + 8*(rcx)], r14
inc rcx
cmp rcx, r11
jne simple_param_loop3
simple_param_end_loop3:
mov qword [rbx], rdx ; put this env in ExtEnv[0]
MAKE_CLOSURE(rax, rbx, Lcode3)
jmp Lcont3
Lcode3:
push rbp
mov rbp, rsp

; Applic

; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*1]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*0]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

cmp rax, SOB_FALSE_ADDRESS
je Lelse4

mov rax, const_tbl + 1

jmp Lexit5
Lelse4:

; Applic

; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

 push rax 
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*2]

 push rax 

 push 2

mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0]
mov rax, qword [rax + 8*1]

mov rax, qword [rax]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 
mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 

 push 2

mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0]
mov rax, qword [rax + 8*0]

mov rax, qword [rax]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 
; Applic

; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

 push rax 
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*1]

 push rax 

 push 2

mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0]
mov rax, qword [rax + 8*1]

mov rax, qword [rax]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 
mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 

 push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*4]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 

 push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*3]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
push qword[ rbp + 8 ] ;;old ret address)
push qword[rbp]    ;;backup old rbp
mov r9, qword[rbp + 8*3]  ;;get old args num
add r9, 4
shl r9, 3             ;;set new r9 = (x+4)*8
;;fix the stack
SHIFT_FRAME 6    ;;args_count + 4 = n + env + ret addrs +old rbp
add rsp, r9            ;;set new stack pointer
pop rbp            ;;restore old rbp
jmp qword[rax + 1 + 8] ;;jmp to code (rax is all the closure, skip tag = +1, skip env = +8)

Lexit5:

leave
ret
Lcont3:

push rax
mov rax, qword [rbp + 8 * (4 + 0)]

pop qword [rax]
mov rax, SOB_VOID_ADDRESS

; LambdaSimple

MALLOC rbx, 24 ; rbx = pointer to ExtEnv
mov qword r8, [rbp + 8*2] ; r8 is a pointer to lexical env
; rbx[i+1] <- r8[i] using r9
mov rcx, 0 ; rcx is the loop var
mov rdx, 2
simple_ext_loop6:
mov r9, qword [r8 + 8*rcx]
mov qword [rbx + 8*(rcx+1)], r9
inc rcx
cmp rcx, rdx
jne simple_ext_loop6
mov r10, qword [rbp + 8 * 3] ; r10 is the number of params in previous env
mov r11, r10 ; save the amount of params
shl r10, 3 ; r10 = r10 * 8 - the real size that we should save
MALLOC rdx, r10
mov rcx, 0 ; rcx is the loop var, r11 is the limit, doing the exchange using r14
cmp r11, 0 ; there is no parameters
je simple_param_end_loop6
simple_param_loop6:
mov r14, PVAR(rcx)
mov qword [rdx + 8*(rcx)], r14
inc rcx
cmp rcx, r11
jne simple_param_loop6
simple_param_end_loop6:
mov qword [rbx], rdx ; put this env in ExtEnv[0]
MAKE_CLOSURE(rax, rbx, Lcode6)
jmp Lcont6
Lcode6:
push rbp
mov rbp, rsp

; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*0]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

cmp rax, SOB_FALSE_ADDRESS
je Lelse7

mov rax, const_tbl + 1

jmp Lexit8
Lelse7:

; Applic

; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*2]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 
mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 

 push 2

mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0]
mov rax, qword [rax + 8*1]

mov rax, qword [rax]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 
; Applic

; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*1]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 

 push 1
mov rax, qword [rbp + 8 * (4 + 0)]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 

 push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*3]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
push qword[ rbp + 8 ] ;;old ret address)
push qword[rbp]    ;;backup old rbp
mov r9, qword[rbp + 8*3]  ;;get old args num
add r9, 4
shl r9, 3             ;;set new r9 = (x+4)*8
;;fix the stack
SHIFT_FRAME 6    ;;args_count + 4 = n + env + ret addrs +old rbp
add rsp, r9            ;;set new stack pointer
pop rbp            ;;restore old rbp
jmp qword[rax + 1 + 8] ;;jmp to code (rax is all the closure, skip tag = +1, skip env = +8)

Lexit8:

leave
ret
Lcont6:

push rax
mov rax, qword [rbp + 8 * (4 + 1)]

pop qword [rax]
mov rax, SOB_VOID_ADDRESS
; LambdaOpt

MALLOC rbx, 24 ; rbx = pointer to ExtEnv
mov qword r8, [rbp + 8*2] ; r8 is a pointer to lexical env
; rbx[i+1] <- r8[i] using r9
mov rcx, 0 ; rcx is the loop var
mov rdx, 2
simple_ext_loop9:
mov r9, qword [r8 + 8*rcx]
mov qword [rbx + 8*(rcx+1)], r9
inc rcx
cmp rcx, rdx
jne simple_ext_loop9
mov r10, qword [rbp + 8 * 3] ; r10 is the number of params in previous env
mov r11, r10 ; save the amount of params
shl r10, 3 ; r10 = r10 * 8 - the real size that we should save
MALLOC rdx, r10
mov rcx, 0 ; rcx is the loop var, r11 is the limit, doing the exchange using r14
cmp r11, 0 ; there is no parameters
je simple_param_end_loop9
simple_param_loop9:
mov r14, PVAR(rcx)
mov qword [rdx + 8*(rcx)], r14
inc rcx
cmp rcx, r11
jne simple_param_loop9
simple_param_end_loop9:
mov qword [rbx], rdx ; put this env in ExtEnv[0]
MAKE_CLOSURE(rax, rbx, Lcode9)
jmp Lcont9
Lcode9:
; Adjust the stack for the optional arguments
mov rbx, qword [rsp + 8*2] ; rbx = actual_n
cmp rbx, 2
jne not_eq9
mov r8, qword [rsp + 8*(2 + rbx)]
mov r10, r8 ; r10 = address of element
MAKE_PAIR (r9, r10, SOB_NIL_ADDRESS) ; r9 = Pair(r10, Nil)
mov qword [rsp + 8*(2 + rbx)], r9 ; stack[n-1] = Pair(element, Nil)
jmp end_of_fix9
not_eq9:
; rbx have the actual n
cmp rbx, 2
jl enlarge_stack9
; new_n < old_n
; create list of rest element
mov rcx, rbx
sub rcx, 2
inc rcx ; Need to Pair the last element as well
mov r9, SOB_NIL_ADDRESS
pair_cons_loop9:
; rcx is the loop counter
; r8 = element from the end of stack to the position of the pair
mov r8, qword [rsp + 8*(2 + 2 + rcx - 1)]
MAKE_PAIR (rdx, r8, r9) ; rdx = Pair(r8, r9)
; update r9
mov r9, rdx
dec rcx
jnz pair_cons_loop9
; r9 has the list
mov qword [rsp + 8 * (2 + 2)], r9
; adjust the stack size from n to 2
mov r8, 2 ; r8 = new_n
add r8, 3 ; r8 = new_stack_size
; We want that rdx will point to the last element
mov rdx, r8
; We want that r10 will point to the last element of old stack
mov r8, rbx ; r8 = old_n
add r8, 3 ; r8 = old_stack_size
mov r10, r8
shift_stack_up9:
; stack[r10-1] <- stack[rdx-1] using r11
dec r10
dec rdx ; it is the smaller
mov r11, qword [rsp + 8*rdx]
mov qword [rsp + 8*r10], r11
jnz shift_stack_up9
; Fix rsp to point right
; r10 hold the diff between this two pointers
mul_small_stack_loop9:
add rsp, 8
dec r10
jnz mul_small_stack_loop9
jmp fix_n9
enlarge_stack9:
; old_n < new_n
; shift down the stack
mov r8, 2 ; r8 = new_n
add r8, 3 ; r8 = new_stack_size
mov rdx, r8 ; rdx = new_stack_size
mov r8, rbx ; r8 = old_n
add r8, 3 ; r8 = old_stack_size
mov r10, r8 ; r10 = old_stack_size
mov r9, 0
sub rsp, 8 ; we need to take down the hole stack
shift_stack_down9:
; stack[r9] <- stack[r9+1] using r11
mov r11, qword [rsp + 8*(r9+1)]
mov qword [rsp + 8*r9], r11
inc r9
dec r10 ; it is the smaller
jnz shift_stack_down9
; rsp is already fixed
; put in the cleared element NIL
mov qword [rsp + 8*(rdx - 1)], SOB_NIL_ADDRESS
fix_n9:
mov qword [rsp + 2*8], 2
end_of_fix9:
push rbp
mov rbp, rsp

mov rax, qword [rbp + 8 * (4 + 1)]

 push rax 
mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 

 push 2

mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0]
mov rax, qword [rax + 8*0]

mov rax, qword [rax]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
push qword[ rbp + 8 ] ;;old ret address)
push qword[rbp]    ;;backup old rbp
mov r9, qword[rbp + 8*3]  ;;get old args num
add r9, 4
shl r9, 3             ;;set new r9 = (x+4)*8
;;fix the stack
SHIFT_FRAME 6    ;;args_count + 4 = n + env + ret addrs +old rbp
add rsp, r9            ;;set new stack pointer
pop rbp            ;;restore old rbp
jmp qword[rax + 1 + 8] ;;jmp to code (rax is all the closure, skip tag = +1, skip env = +8)

leave
ret
Lcont9:

leave
ret
Lcont2:

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
push qword[ rbp + 8 ] ;;old ret address)
push qword[rbp]    ;;backup old rbp
mov r9, qword[rbp + 8*3]  ;;get old args num
add r9, 4
shl r9, 3             ;;set new r9 = (x+4)*8
;;fix the stack
SHIFT_FRAME 6    ;;args_count + 4 = n + env + ret addrs +old rbp
add rsp, r9            ;;set new stack pointer
pop rbp            ;;restore old rbp
jmp qword[rax + 1 + 8] ;;jmp to code (rax is all the closure, skip tag = +1, skip env = +8)

leave
ret
Lcont1:

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

mov qword [fvar_tbl + 8*32], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; Applic

mov rax, qword [fvar_tbl + 8*27]

 push rax 
mov rax, qword [fvar_tbl + 8*26]

 push rax 
mov rax, qword [fvar_tbl + 8*4]

 push rax 

 push 3
; LambdaSimple

MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode10)
jmp Lcont10
Lcode10:
push rbp
mov rbp, rsp


mov rax, const_tbl + 23

 push rax 

 push 1
; LambdaSimple

MALLOC rbx, 16 ; rbx = pointer to ExtEnv
mov qword r8, [rbp + 8*2] ; r8 is a pointer to lexical env
; rbx[i+1] <- r8[i] using r9
mov rcx, 0 ; rcx is the loop var
mov rdx, 1
simple_ext_loop11:
mov r9, qword [r8 + 8*rcx]
mov qword [rbx + 8*(rcx+1)], r9
inc rcx
cmp rcx, rdx
jne simple_ext_loop11
mov r10, qword [rbp + 8 * 3] ; r10 is the number of params in previous env
mov r11, r10 ; save the amount of params
shl r10, 3 ; r10 = r10 * 8 - the real size that we should save
MALLOC rdx, r10
mov rcx, 0 ; rcx is the loop var, r11 is the limit, doing the exchange using r14
cmp r11, 0 ; there is no parameters
je simple_param_end_loop11
simple_param_loop11:
mov r14, PVAR(rcx)
mov qword [rdx + 8*(rcx)], r14
inc rcx
cmp rcx, r11
jne simple_param_loop11
simple_param_end_loop11:
mov qword [rbx], rdx ; put this env in ExtEnv[0]
MAKE_CLOSURE(rax, rbx, Lcode11)
jmp Lcont11
Lcode11:
push rbp
mov rbp, rsp



mov rax, qword [rbp + 8 * (4 + 0)]

MALLOC r8, 8
mov qword[r8], rax
mov rax, r8

mov qword [rbp + 8 * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS

; LambdaSimple

MALLOC rbx, 24 ; rbx = pointer to ExtEnv
mov qword r8, [rbp + 8*2] ; r8 is a pointer to lexical env
; rbx[i+1] <- r8[i] using r9
mov rcx, 0 ; rcx is the loop var
mov rdx, 2
simple_ext_loop12:
mov r9, qword [r8 + 8*rcx]
mov qword [rbx + 8*(rcx+1)], r9
inc rcx
cmp rcx, rdx
jne simple_ext_loop12
mov r10, qword [rbp + 8 * 3] ; r10 is the number of params in previous env
mov r11, r10 ; save the amount of params
shl r10, 3 ; r10 = r10 * 8 - the real size that we should save
MALLOC rdx, r10
mov rcx, 0 ; rcx is the loop var, r11 is the limit, doing the exchange using r14
cmp r11, 0 ; there is no parameters
je simple_param_end_loop12
simple_param_loop12:
mov r14, PVAR(rcx)
mov qword [rdx + 8*(rcx)], r14
inc rcx
cmp rcx, r11
jne simple_param_loop12
simple_param_end_loop12:
mov qword [rbx], rdx ; put this env in ExtEnv[0]
MAKE_CLOSURE(rax, rbx, Lcode12)
jmp Lcont12
Lcode12:
push rbp
mov rbp, rsp

; Applic

mov rax, qword [rbp + 8 * (4 + 2)]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*0]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

cmp rax, SOB_FALSE_ADDRESS
je Lelse13
mov rax, qword [rbp + 8 * (4 + 1)]

jmp Lexit14
Lelse13:

; Applic

mov rax, qword [rbp + 8 * (4 + 2)]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*2]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 
; Applic

; Applic

mov rax, qword [rbp + 8 * (4 + 2)]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*1]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 
mov rax, qword [rbp + 8 * (4 + 1)]

 push rax 

 push 2
mov rax, qword [rbp + 8 * (4 + 0)]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 
mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 

 push 3

mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0]
mov rax, qword [rax + 8*0]

mov rax, qword [rax]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
push qword[ rbp + 8 ] ;;old ret address)
push qword[rbp]    ;;backup old rbp
mov r9, qword[rbp + 8*3]  ;;get old args num
add r9, 4
shl r9, 3             ;;set new r9 = (x+4)*8
;;fix the stack
SHIFT_FRAME 7    ;;args_count + 4 = n + env + ret addrs +old rbp
add rsp, r9            ;;set new stack pointer
pop rbp            ;;restore old rbp
jmp qword[rax + 1 + 8] ;;jmp to code (rax is all the closure, skip tag = +1, skip env = +8)

Lexit14:

leave
ret
Lcont12:

push rax
mov rax, qword [rbp + 8 * (4 + 0)]

pop qword [rax]
mov rax, SOB_VOID_ADDRESS

mov rax, qword [rbp + 8 * (4 + 0)]

mov rax, qword [rax]

leave
ret
Lcont11:

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
push qword[ rbp + 8 ] ;;old ret address)
push qword[rbp]    ;;backup old rbp
mov r9, qword[rbp + 8*3]  ;;get old args num
add r9, 4
shl r9, 3             ;;set new r9 = (x+4)*8
;;fix the stack
SHIFT_FRAME 5    ;;args_count + 4 = n + env + ret addrs +old rbp
add rsp, r9            ;;set new stack pointer
pop rbp            ;;restore old rbp
jmp qword[rax + 1 + 8] ;;jmp to code (rax is all the closure, skip tag = +1, skip env = +8)

leave
ret
Lcont10:

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

mov qword [fvar_tbl + 8*33], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; Applic

mov rax, qword [fvar_tbl + 8*27]

 push rax 
mov rax, qword [fvar_tbl + 8*26]

 push rax 
mov rax, qword [fvar_tbl + 8*4]

 push rax 

 push 3
; LambdaSimple

MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode15)
jmp Lcont15
Lcode15:
push rbp
mov rbp, rsp


mov rax, const_tbl + 23

 push rax 

 push 1
; LambdaSimple

MALLOC rbx, 16 ; rbx = pointer to ExtEnv
mov qword r8, [rbp + 8*2] ; r8 is a pointer to lexical env
; rbx[i+1] <- r8[i] using r9
mov rcx, 0 ; rcx is the loop var
mov rdx, 1
simple_ext_loop16:
mov r9, qword [r8 + 8*rcx]
mov qword [rbx + 8*(rcx+1)], r9
inc rcx
cmp rcx, rdx
jne simple_ext_loop16
mov r10, qword [rbp + 8 * 3] ; r10 is the number of params in previous env
mov r11, r10 ; save the amount of params
shl r10, 3 ; r10 = r10 * 8 - the real size that we should save
MALLOC rdx, r10
mov rcx, 0 ; rcx is the loop var, r11 is the limit, doing the exchange using r14
cmp r11, 0 ; there is no parameters
je simple_param_end_loop16
simple_param_loop16:
mov r14, PVAR(rcx)
mov qword [rdx + 8*(rcx)], r14
inc rcx
cmp rcx, r11
jne simple_param_loop16
simple_param_end_loop16:
mov qword [rbx], rdx ; put this env in ExtEnv[0]
MAKE_CLOSURE(rax, rbx, Lcode16)
jmp Lcont16
Lcode16:
push rbp
mov rbp, rsp



mov rax, qword [rbp + 8 * (4 + 0)]

MALLOC r8, 8
mov qword[r8], rax
mov rax, r8

mov qword [rbp + 8 * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS

; LambdaSimple

MALLOC rbx, 24 ; rbx = pointer to ExtEnv
mov qword r8, [rbp + 8*2] ; r8 is a pointer to lexical env
; rbx[i+1] <- r8[i] using r9
mov rcx, 0 ; rcx is the loop var
mov rdx, 2
simple_ext_loop17:
mov r9, qword [r8 + 8*rcx]
mov qword [rbx + 8*(rcx+1)], r9
inc rcx
cmp rcx, rdx
jne simple_ext_loop17
mov r10, qword [rbp + 8 * 3] ; r10 is the number of params in previous env
mov r11, r10 ; save the amount of params
shl r10, 3 ; r10 = r10 * 8 - the real size that we should save
MALLOC rdx, r10
mov rcx, 0 ; rcx is the loop var, r11 is the limit, doing the exchange using r14
cmp r11, 0 ; there is no parameters
je simple_param_end_loop17
simple_param_loop17:
mov r14, PVAR(rcx)
mov qword [rdx + 8*(rcx)], r14
inc rcx
cmp rcx, r11
jne simple_param_loop17
simple_param_end_loop17:
mov qword [rbx], rdx ; put this env in ExtEnv[0]
MAKE_CLOSURE(rax, rbx, Lcode17)
jmp Lcont17
Lcode17:
push rbp
mov rbp, rsp

; Applic

mov rax, qword [rbp + 8 * (4 + 2)]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*0]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

cmp rax, SOB_FALSE_ADDRESS
je Lelse18
mov rax, qword [rbp + 8 * (4 + 1)]

jmp Lexit19
Lelse18:

; Applic

; Applic

mov rax, qword [rbp + 8 * (4 + 2)]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*2]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 
mov rax, qword [rbp + 8 * (4 + 1)]

 push rax 
mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 

 push 3

mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0]
mov rax, qword [rax + 8*0]

mov rax, qword [rax]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 
; Applic

mov rax, qword [rbp + 8 * (4 + 2)]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*1]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 

 push 2
mov rax, qword [rbp + 8 * (4 + 0)]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
push qword[ rbp + 8 ] ;;old ret address)
push qword[rbp]    ;;backup old rbp
mov r9, qword[rbp + 8*3]  ;;get old args num
add r9, 4
shl r9, 3             ;;set new r9 = (x+4)*8
;;fix the stack
SHIFT_FRAME 6    ;;args_count + 4 = n + env + ret addrs +old rbp
add rsp, r9            ;;set new stack pointer
pop rbp            ;;restore old rbp
jmp qword[rax + 1 + 8] ;;jmp to code (rax is all the closure, skip tag = +1, skip env = +8)

Lexit19:

leave
ret
Lcont17:

push rax
mov rax, qword [rbp + 8 * (4 + 0)]

pop qword [rax]
mov rax, SOB_VOID_ADDRESS

mov rax, qword [rbp + 8 * (4 + 0)]

mov rax, qword [rax]

leave
ret
Lcont16:

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
push qword[ rbp + 8 ] ;;old ret address)
push qword[rbp]    ;;backup old rbp
mov r9, qword[rbp + 8*3]  ;;get old args num
add r9, 4
shl r9, 3             ;;set new r9 = (x+4)*8
;;fix the stack
SHIFT_FRAME 5    ;;args_count + 4 = n + env + ret addrs +old rbp
add rsp, r9            ;;set new stack pointer
pop rbp            ;;restore old rbp
jmp qword[rax + 1 + 8] ;;jmp to code (rax is all the closure, skip tag = +1, skip env = +8)

leave
ret
Lcont15:

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

mov qword [fvar_tbl + 8*34], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; Applic

mov rax, qword [fvar_tbl + 8*27]

 push rax 
mov rax, qword [fvar_tbl + 8*26]

 push rax 

 push 2
; LambdaSimple

MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode20)
jmp Lcont20
Lcode20:
push rbp
mov rbp, rsp


mov rax, const_tbl + 23

 push rax 

 push 1
; LambdaSimple

MALLOC rbx, 16 ; rbx = pointer to ExtEnv
mov qword r8, [rbp + 8*2] ; r8 is a pointer to lexical env
; rbx[i+1] <- r8[i] using r9
mov rcx, 0 ; rcx is the loop var
mov rdx, 1
simple_ext_loop21:
mov r9, qword [r8 + 8*rcx]
mov qword [rbx + 8*(rcx+1)], r9
inc rcx
cmp rcx, rdx
jne simple_ext_loop21
mov r10, qword [rbp + 8 * 3] ; r10 is the number of params in previous env
mov r11, r10 ; save the amount of params
shl r10, 3 ; r10 = r10 * 8 - the real size that we should save
MALLOC rdx, r10
mov rcx, 0 ; rcx is the loop var, r11 is the limit, doing the exchange using r14
cmp r11, 0 ; there is no parameters
je simple_param_end_loop21
simple_param_loop21:
mov r14, PVAR(rcx)
mov qword [rdx + 8*(rcx)], r14
inc rcx
cmp rcx, r11
jne simple_param_loop21
simple_param_end_loop21:
mov qword [rbx], rdx ; put this env in ExtEnv[0]
MAKE_CLOSURE(rax, rbx, Lcode21)
jmp Lcont21
Lcode21:
push rbp
mov rbp, rsp



mov rax, qword [rbp + 8 * (4 + 0)]

MALLOC r8, 8
mov qword[r8], rax
mov rax, r8

mov qword [rbp + 8 * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS

; LambdaSimple

MALLOC rbx, 24 ; rbx = pointer to ExtEnv
mov qword r8, [rbp + 8*2] ; r8 is a pointer to lexical env
; rbx[i+1] <- r8[i] using r9
mov rcx, 0 ; rcx is the loop var
mov rdx, 2
simple_ext_loop22:
mov r9, qword [r8 + 8*rcx]
mov qword [rbx + 8*(rcx+1)], r9
inc rcx
cmp rcx, rdx
jne simple_ext_loop22
mov r10, qword [rbp + 8 * 3] ; r10 is the number of params in previous env
mov r11, r10 ; save the amount of params
shl r10, 3 ; r10 = r10 * 8 - the real size that we should save
MALLOC rdx, r10
mov rcx, 0 ; rcx is the loop var, r11 is the limit, doing the exchange using r14
cmp r11, 0 ; there is no parameters
je simple_param_end_loop22
simple_param_loop22:
mov r14, PVAR(rcx)
mov qword [rdx + 8*(rcx)], r14
inc rcx
cmp rcx, r11
jne simple_param_loop22
simple_param_end_loop22:
mov qword [rbx], rdx ; put this env in ExtEnv[0]
MAKE_CLOSURE(rax, rbx, Lcode22)
jmp Lcont22
Lcode22:
push rbp
mov rbp, rsp

; Applic


mov rax, const_tbl + 32

 push rax 
; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 

 push 1
mov rax, qword [fvar_tbl + 8*47]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 

 push 2
mov rax, qword [fvar_tbl + 8*21]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

cmp rax, SOB_FALSE_ADDRESS
je Lelse23

mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*0]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
push qword[ rbp + 8 ] ;;old ret address)
push qword[rbp]    ;;backup old rbp
mov r9, qword[rbp + 8*3]  ;;get old args num
add r9, 4
shl r9, 3             ;;set new r9 = (x+4)*8
;;fix the stack
SHIFT_FRAME 5    ;;args_count + 4 = n + env + ret addrs +old rbp
add rsp, r9            ;;set new stack pointer
pop rbp            ;;restore old rbp
jmp qword[rax + 1 + 8] ;;jmp to code (rax is all the closure, skip tag = +1, skip env = +8)

jmp Lexit24
Lelse23:

; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*1]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 

 push 1

mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0]
mov rax, qword [rax + 8*0]

mov rax, qword [rax]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
push qword[ rbp + 8 ] ;;old ret address)
push qword[rbp]    ;;backup old rbp
mov r9, qword[rbp + 8*3]  ;;get old args num
add r9, 4
shl r9, 3             ;;set new r9 = (x+4)*8
;;fix the stack
SHIFT_FRAME 5    ;;args_count + 4 = n + env + ret addrs +old rbp
add rsp, r9            ;;set new stack pointer
pop rbp            ;;restore old rbp
jmp qword[rax + 1 + 8] ;;jmp to code (rax is all the closure, skip tag = +1, skip env = +8)

Lexit24:

leave
ret
Lcont22:

push rax
mov rax, qword [rbp + 8 * (4 + 0)]

pop qword [rax]
mov rax, SOB_VOID_ADDRESS

mov rax, qword [rbp + 8 * (4 + 0)]

mov rax, qword [rax]

leave
ret
Lcont21:

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
push qword[ rbp + 8 ] ;;old ret address)
push qword[rbp]    ;;backup old rbp
mov r9, qword[rbp + 8*3]  ;;get old args num
add r9, 4
shl r9, 3             ;;set new r9 = (x+4)*8
;;fix the stack
SHIFT_FRAME 5    ;;args_count + 4 = n + env + ret addrs +old rbp
add rsp, r9            ;;set new stack pointer
pop rbp            ;;restore old rbp
jmp qword[rax + 1 + 8] ;;jmp to code (rax is all the closure, skip tag = +1, skip env = +8)

leave
ret
Lcont20:

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

mov qword [fvar_tbl + 8*35], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; Applic

mov rax, qword [fvar_tbl + 8*27]

 push rax 
mov rax, qword [fvar_tbl + 8*26]

 push rax 

 push 2
; LambdaSimple

MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode25)
jmp Lcont25
Lcode25:
push rbp
mov rbp, rsp


mov rax, const_tbl + 23

 push rax 

 push 1
; LambdaSimple

MALLOC rbx, 16 ; rbx = pointer to ExtEnv
mov qword r8, [rbp + 8*2] ; r8 is a pointer to lexical env
; rbx[i+1] <- r8[i] using r9
mov rcx, 0 ; rcx is the loop var
mov rdx, 1
simple_ext_loop26:
mov r9, qword [r8 + 8*rcx]
mov qword [rbx + 8*(rcx+1)], r9
inc rcx
cmp rcx, rdx
jne simple_ext_loop26
mov r10, qword [rbp + 8 * 3] ; r10 is the number of params in previous env
mov r11, r10 ; save the amount of params
shl r10, 3 ; r10 = r10 * 8 - the real size that we should save
MALLOC rdx, r10
mov rcx, 0 ; rcx is the loop var, r11 is the limit, doing the exchange using r14
cmp r11, 0 ; there is no parameters
je simple_param_end_loop26
simple_param_loop26:
mov r14, PVAR(rcx)
mov qword [rdx + 8*(rcx)], r14
inc rcx
cmp rcx, r11
jne simple_param_loop26
simple_param_end_loop26:
mov qword [rbx], rdx ; put this env in ExtEnv[0]
MAKE_CLOSURE(rax, rbx, Lcode26)
jmp Lcont26
Lcode26:
push rbp
mov rbp, rsp



mov rax, qword [rbp + 8 * (4 + 0)]

MALLOC r8, 8
mov qword[r8], rax
mov rax, r8

mov qword [rbp + 8 * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS

; LambdaSimple

MALLOC rbx, 24 ; rbx = pointer to ExtEnv
mov qword r8, [rbp + 8*2] ; r8 is a pointer to lexical env
; rbx[i+1] <- r8[i] using r9
mov rcx, 0 ; rcx is the loop var
mov rdx, 2
simple_ext_loop27:
mov r9, qword [r8 + 8*rcx]
mov qword [rbx + 8*(rcx+1)], r9
inc rcx
cmp rcx, rdx
jne simple_ext_loop27
mov r10, qword [rbp + 8 * 3] ; r10 is the number of params in previous env
mov r11, r10 ; save the amount of params
shl r10, 3 ; r10 = r10 * 8 - the real size that we should save
MALLOC rdx, r10
mov rcx, 0 ; rcx is the loop var, r11 is the limit, doing the exchange using r14
cmp r11, 0 ; there is no parameters
je simple_param_end_loop27
simple_param_loop27:
mov r14, PVAR(rcx)
mov qword [rdx + 8*(rcx)], r14
inc rcx
cmp rcx, r11
jne simple_param_loop27
simple_param_end_loop27:
mov qword [rbx], rdx ; put this env in ExtEnv[0]
MAKE_CLOSURE(rax, rbx, Lcode27)
jmp Lcont27
Lcode27:
push rbp
mov rbp, rsp

; Applic

; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*1]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 

 push 1
mov rax, qword [fvar_tbl + 8*4]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

cmp rax, SOB_FALSE_ADDRESS
je Lelse28

mov rax, const_tbl + 1

jmp Lexit29
Lelse28:

; Applic

; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*1]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 

 push 1

mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0]
mov rax, qword [rax + 8*0]

mov rax, qword [rax]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 
; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*0]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 

 push 2
mov rax, qword [fvar_tbl + 8*28]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
push qword[ rbp + 8 ] ;;old ret address)
push qword[rbp]    ;;backup old rbp
mov r9, qword[rbp + 8*3]  ;;get old args num
add r9, 4
shl r9, 3             ;;set new r9 = (x+4)*8
;;fix the stack
SHIFT_FRAME 6    ;;args_count + 4 = n + env + ret addrs +old rbp
add rsp, r9            ;;set new stack pointer
pop rbp            ;;restore old rbp
jmp qword[rax + 1 + 8] ;;jmp to code (rax is all the closure, skip tag = +1, skip env = +8)

Lexit29:

leave
ret
Lcont27:

push rax
mov rax, qword [rbp + 8 * (4 + 0)]

pop qword [rax]
mov rax, SOB_VOID_ADDRESS

mov rax, qword [rbp + 8 * (4 + 0)]

mov rax, qword [rax]

leave
ret
Lcont26:

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
push qword[ rbp + 8 ] ;;old ret address)
push qword[rbp]    ;;backup old rbp
mov r9, qword[rbp + 8*3]  ;;get old args num
add r9, 4
shl r9, 3             ;;set new r9 = (x+4)*8
;;fix the stack
SHIFT_FRAME 5    ;;args_count + 4 = n + env + ret addrs +old rbp
add rsp, r9            ;;set new stack pointer
pop rbp            ;;restore old rbp
jmp qword[rax + 1 + 8] ;;jmp to code (rax is all the closure, skip tag = +1, skip env = +8)

leave
ret
Lcont25:

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

mov qword [fvar_tbl + 8*36], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; LambdaOpt

MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode30)
jmp Lcont30
Lcode30:
; Adjust the stack for the optional arguments
mov rbx, qword [rsp + 8*2] ; rbx = actual_n
cmp rbx, 2
jne not_eq30
mov r8, qword [rsp + 8*(2 + rbx)]
mov r10, r8 ; r10 = address of element
MAKE_PAIR (r9, r10, SOB_NIL_ADDRESS) ; r9 = Pair(r10, Nil)
mov qword [rsp + 8*(2 + rbx)], r9 ; stack[n-1] = Pair(element, Nil)
jmp end_of_fix30
not_eq30:
; rbx have the actual n
cmp rbx, 2
jl enlarge_stack30
; new_n < old_n
; create list of rest element
mov rcx, rbx
sub rcx, 2
inc rcx ; Need to Pair the last element as well
mov r9, SOB_NIL_ADDRESS
pair_cons_loop30:
; rcx is the loop counter
; r8 = element from the end of stack to the position of the pair
mov r8, qword [rsp + 8*(2 + 2 + rcx - 1)]
MAKE_PAIR (rdx, r8, r9) ; rdx = Pair(r8, r9)
; update r9
mov r9, rdx
dec rcx
jnz pair_cons_loop30
; r9 has the list
mov qword [rsp + 8 * (2 + 2)], r9
; adjust the stack size from n to 2
mov r8, 2 ; r8 = new_n
add r8, 3 ; r8 = new_stack_size
; We want that rdx will point to the last element
mov rdx, r8
; We want that r10 will point to the last element of old stack
mov r8, rbx ; r8 = old_n
add r8, 3 ; r8 = old_stack_size
mov r10, r8
shift_stack_up30:
; stack[r10-1] <- stack[rdx-1] using r11
dec r10
dec rdx ; it is the smaller
mov r11, qword [rsp + 8*rdx]
mov qword [rsp + 8*r10], r11
jnz shift_stack_up30
; Fix rsp to point right
; r10 hold the diff between this two pointers
mul_small_stack_loop30:
add rsp, 8
dec r10
jnz mul_small_stack_loop30
jmp fix_n30
enlarge_stack30:
; old_n < new_n
; shift down the stack
mov r8, 2 ; r8 = new_n
add r8, 3 ; r8 = new_stack_size
mov rdx, r8 ; rdx = new_stack_size
mov r8, rbx ; r8 = old_n
add r8, 3 ; r8 = old_stack_size
mov r10, r8 ; r10 = old_stack_size
mov r9, 0
sub rsp, 8 ; we need to take down the hole stack
shift_stack_down30:
; stack[r9] <- stack[r9+1] using r11
mov r11, qword [rsp + 8*(r9+1)]
mov qword [rsp + 8*r9], r11
inc r9
dec r10 ; it is the smaller
jnz shift_stack_down30
; rsp is already fixed
; put in the cleared element NIL
mov qword [rsp + 8*(rdx - 1)], SOB_NIL_ADDRESS
fix_n30:
mov qword [rsp + 2*8], 2
end_of_fix30:
push rbp
mov rbp, rsp

mov rax, qword [fvar_tbl + 8*28]

 push rax 
mov rax, qword [fvar_tbl + 8*27]

 push rax 
mov rax, qword [fvar_tbl + 8*26]

 push rax 
mov rax, qword [fvar_tbl + 8*4]

 push rax 

 push 4
; LambdaSimple

MALLOC rbx, 16 ; rbx = pointer to ExtEnv
mov qword r8, [rbp + 8*2] ; r8 is a pointer to lexical env
; rbx[i+1] <- r8[i] using r9
mov rcx, 0 ; rcx is the loop var
mov rdx, 1
simple_ext_loop31:
mov r9, qword [r8 + 8*rcx]
mov qword [rbx + 8*(rcx+1)], r9
inc rcx
cmp rcx, rdx
jne simple_ext_loop31
mov r10, qword [rbp + 8 * 3] ; r10 is the number of params in previous env
mov r11, r10 ; save the amount of params
shl r10, 3 ; r10 = r10 * 8 - the real size that we should save
MALLOC rdx, r10
mov rcx, 0 ; rcx is the loop var, r11 is the limit, doing the exchange using r14
cmp r11, 0 ; there is no parameters
je simple_param_end_loop31
simple_param_loop31:
mov r14, PVAR(rcx)
mov qword [rdx + 8*(rcx)], r14
inc rcx
cmp rcx, r11
jne simple_param_loop31
simple_param_end_loop31:
mov qword [rbx], rdx ; put this env in ExtEnv[0]
MAKE_CLOSURE(rax, rbx, Lcode31)
jmp Lcont31
Lcode31:
push rbp
mov rbp, rsp

; Applic

mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0]
mov rax, qword [rax + 8*1]

 push rax 

 push 1
mov rax, qword [rbp + 8 * (4 + 0)]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

cmp rax, SOB_FALSE_ADDRESS
je Lelse32
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0]
mov rax, qword [rax + 8*0]

jmp Lexit33
Lelse32:

; Applic

; Applic

mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0]
mov rax, qword [rax + 8*1]

 push rax 
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0]
mov rax, qword [rax + 8*0]

 push rax 

 push 2
mov rax, qword [rbp + 8 * (4 + 3)]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 

 push 1
mov rax, qword [fvar_tbl + 8*36]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 
; Applic

mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0]
mov rax, qword [rax + 8*1]

 push rax 

 push 1
mov rax, qword [fvar_tbl + 8*35]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 
mov rax, qword [rbp + 8 * (4 + 3)]

 push rax 

 push 3
mov rax, qword [fvar_tbl + 8*34]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
push qword[ rbp + 8 ] ;;old ret address)
push qword[rbp]    ;;backup old rbp
mov r9, qword[rbp + 8*3]  ;;get old args num
add r9, 4
shl r9, 3             ;;set new r9 = (x+4)*8
;;fix the stack
SHIFT_FRAME 7    ;;args_count + 4 = n + env + ret addrs +old rbp
add rsp, r9            ;;set new stack pointer
pop rbp            ;;restore old rbp
jmp qword[rax + 1 + 8] ;;jmp to code (rax is all the closure, skip tag = +1, skip env = +8)

Lexit33:

leave
ret
Lcont31:

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
push qword[ rbp + 8 ] ;;old ret address)
push qword[rbp]    ;;backup old rbp
mov r9, qword[rbp + 8*3]  ;;get old args num
add r9, 4
shl r9, 3             ;;set new r9 = (x+4)*8
;;fix the stack
SHIFT_FRAME 8    ;;args_count + 4 = n + env + ret addrs +old rbp
add rsp, r9            ;;set new stack pointer
pop rbp            ;;restore old rbp
jmp qword[rax + 1 + 8] ;;jmp to code (rax is all the closure, skip tag = +1, skip env = +8)

leave
ret
Lcont30:

mov qword [fvar_tbl + 8*37], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; Applic

mov rax, qword [fvar_tbl + 8*28]

 push rax 
mov rax, qword [fvar_tbl + 8*34]

 push rax 
mov rax, qword [fvar_tbl + 8*4]

 push rax 

 push 3
; LambdaSimple

MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode34)
jmp Lcont34
Lcode34:
push rbp
mov rbp, rsp
; LambdaOpt

MALLOC rbx, 16 ; rbx = pointer to ExtEnv
mov qword r8, [rbp + 8*2] ; r8 is a pointer to lexical env
; rbx[i+1] <- r8[i] using r9
mov rcx, 0 ; rcx is the loop var
mov rdx, 1
simple_ext_loop35:
mov r9, qword [r8 + 8*rcx]
mov qword [rbx + 8*(rcx+1)], r9
inc rcx
cmp rcx, rdx
jne simple_ext_loop35
mov r10, qword [rbp + 8 * 3] ; r10 is the number of params in previous env
mov r11, r10 ; save the amount of params
shl r10, 3 ; r10 = r10 * 8 - the real size that we should save
MALLOC rdx, r10
mov rcx, 0 ; rcx is the loop var, r11 is the limit, doing the exchange using r14
cmp r11, 0 ; there is no parameters
je simple_param_end_loop35
simple_param_loop35:
mov r14, PVAR(rcx)
mov qword [rdx + 8*(rcx)], r14
inc rcx
cmp rcx, r11
jne simple_param_loop35
simple_param_end_loop35:
mov qword [rbx], rdx ; put this env in ExtEnv[0]
MAKE_CLOSURE(rax, rbx, Lcode35)
jmp Lcont35
Lcode35:
; Adjust the stack for the optional arguments
mov rbx, qword [rsp + 8*2] ; rbx = actual_n
cmp rbx, 1
jne not_eq35
mov r8, qword [rsp + 8*(2 + rbx)]
mov r10, r8 ; r10 = address of element
MAKE_PAIR (r9, r10, SOB_NIL_ADDRESS) ; r9 = Pair(r10, Nil)
mov qword [rsp + 8*(2 + rbx)], r9 ; stack[n-1] = Pair(element, Nil)
jmp end_of_fix35
not_eq35:
; rbx have the actual n
cmp rbx, 1
jl enlarge_stack35
; new_n < old_n
; create list of rest element
mov rcx, rbx
sub rcx, 1
inc rcx ; Need to Pair the last element as well
mov r9, SOB_NIL_ADDRESS
pair_cons_loop35:
; rcx is the loop counter
; r8 = element from the end of stack to the position of the pair
mov r8, qword [rsp + 8*(2 + 1 + rcx - 1)]
MAKE_PAIR (rdx, r8, r9) ; rdx = Pair(r8, r9)
; update r9
mov r9, rdx
dec rcx
jnz pair_cons_loop35
; r9 has the list
mov qword [rsp + 8 * (2 + 1)], r9
; adjust the stack size from n to 1
mov r8, 1 ; r8 = new_n
add r8, 3 ; r8 = new_stack_size
; We want that rdx will point to the last element
mov rdx, r8
; We want that r10 will point to the last element of old stack
mov r8, rbx ; r8 = old_n
add r8, 3 ; r8 = old_stack_size
mov r10, r8
shift_stack_up35:
; stack[r10-1] <- stack[rdx-1] using r11
dec r10
dec rdx ; it is the smaller
mov r11, qword [rsp + 8*rdx]
mov qword [rsp + 8*r10], r11
jnz shift_stack_up35
; Fix rsp to point right
; r10 hold the diff between this two pointers
mul_small_stack_loop35:
add rsp, 8
dec r10
jnz mul_small_stack_loop35
jmp fix_n35
enlarge_stack35:
; old_n < new_n
; shift down the stack
mov r8, 1 ; r8 = new_n
add r8, 3 ; r8 = new_stack_size
mov rdx, r8 ; rdx = new_stack_size
mov r8, rbx ; r8 = old_n
add r8, 3 ; r8 = old_stack_size
mov r10, r8 ; r10 = old_stack_size
mov r9, 0
sub rsp, 8 ; we need to take down the hole stack
shift_stack_down35:
; stack[r9] <- stack[r9+1] using r11
mov r11, qword [rsp + 8*(r9+1)]
mov qword [rsp + 8*r9], r11
inc r9
dec r10 ; it is the smaller
jnz shift_stack_down35
; rsp is already fixed
; put in the cleared element NIL
mov qword [rsp + 8*(rdx - 1)], SOB_NIL_ADDRESS
fix_n35:
mov qword [rsp + 2*8], 1
end_of_fix35:
push rbp
mov rbp, rsp

mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 

mov rax, const_tbl + 1

 push rax 
; LambdaSimple

MALLOC rbx, 24 ; rbx = pointer to ExtEnv
mov qword r8, [rbp + 8*2] ; r8 is a pointer to lexical env
; rbx[i+1] <- r8[i] using r9
mov rcx, 0 ; rcx is the loop var
mov rdx, 2
simple_ext_loop36:
mov r9, qword [r8 + 8*rcx]
mov qword [rbx + 8*(rcx+1)], r9
inc rcx
cmp rcx, rdx
jne simple_ext_loop36
mov r10, qword [rbp + 8 * 3] ; r10 is the number of params in previous env
mov r11, r10 ; save the amount of params
shl r10, 3 ; r10 = r10 * 8 - the real size that we should save
MALLOC rdx, r10
mov rcx, 0 ; rcx is the loop var, r11 is the limit, doing the exchange using r14
cmp r11, 0 ; there is no parameters
je simple_param_end_loop36
simple_param_loop36:
mov r14, PVAR(rcx)
mov qword [rdx + 8*(rcx)], r14
inc rcx
cmp rcx, r11
jne simple_param_loop36
simple_param_end_loop36:
mov qword [rbx], rdx ; put this env in ExtEnv[0]
MAKE_CLOSURE(rax, rbx, Lcode36)
jmp Lcont36
Lcode36:
push rbp
mov rbp, rsp

; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*0]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

cmp rax, SOB_FALSE_ADDRESS
je Lelse37
mov rax, qword [rbp + 8 * (4 + 0)]

jmp Lexit38
Lelse37:

mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 
mov rax, qword [rbp + 8 * (4 + 1)]

 push rax 
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*2]

 push rax 

 push 3
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*1]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
push qword[ rbp + 8 ] ;;old ret address)
push qword[rbp]    ;;backup old rbp
mov r9, qword[rbp + 8*3]  ;;get old args num
add r9, 4
shl r9, 3             ;;set new r9 = (x+4)*8
;;fix the stack
SHIFT_FRAME 7    ;;args_count + 4 = n + env + ret addrs +old rbp
add rsp, r9            ;;set new stack pointer
pop rbp            ;;restore old rbp
jmp qword[rax + 1 + 8] ;;jmp to code (rax is all the closure, skip tag = +1, skip env = +8)

Lexit38:

leave
ret
Lcont36:

 push rax 

 push 3
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0]
mov rax, qword [rax + 8*1]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
push qword[ rbp + 8 ] ;;old ret address)
push qword[rbp]    ;;backup old rbp
mov r9, qword[rbp + 8*3]  ;;get old args num
add r9, 4
shl r9, 3             ;;set new r9 = (x+4)*8
;;fix the stack
SHIFT_FRAME 7    ;;args_count + 4 = n + env + ret addrs +old rbp
add rsp, r9            ;;set new stack pointer
pop rbp            ;;restore old rbp
jmp qword[rax + 1 + 8] ;;jmp to code (rax is all the closure, skip tag = +1, skip env = +8)

leave
ret
Lcont35:

leave
ret
Lcont34:

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

mov qword [fvar_tbl + 8*38], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; LambdaOpt

MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode39)
jmp Lcont39
Lcode39:
; Adjust the stack for the optional arguments
mov rbx, qword [rsp + 8*2] ; rbx = actual_n
cmp rbx, 1
jne not_eq39
mov r8, qword [rsp + 8*(2 + rbx)]
mov r10, r8 ; r10 = address of element
MAKE_PAIR (r9, r10, SOB_NIL_ADDRESS) ; r9 = Pair(r10, Nil)
mov qword [rsp + 8*(2 + rbx)], r9 ; stack[n-1] = Pair(element, Nil)
jmp end_of_fix39
not_eq39:
; rbx have the actual n
cmp rbx, 1
jl enlarge_stack39
; new_n < old_n
; create list of rest element
mov rcx, rbx
sub rcx, 1
inc rcx ; Need to Pair the last element as well
mov r9, SOB_NIL_ADDRESS
pair_cons_loop39:
; rcx is the loop counter
; r8 = element from the end of stack to the position of the pair
mov r8, qword [rsp + 8*(2 + 1 + rcx - 1)]
MAKE_PAIR (rdx, r8, r9) ; rdx = Pair(r8, r9)
; update r9
mov r9, rdx
dec rcx
jnz pair_cons_loop39
; r9 has the list
mov qword [rsp + 8 * (2 + 1)], r9
; adjust the stack size from n to 1
mov r8, 1 ; r8 = new_n
add r8, 3 ; r8 = new_stack_size
; We want that rdx will point to the last element
mov rdx, r8
; We want that r10 will point to the last element of old stack
mov r8, rbx ; r8 = old_n
add r8, 3 ; r8 = old_stack_size
mov r10, r8
shift_stack_up39:
; stack[r10-1] <- stack[rdx-1] using r11
dec r10
dec rdx ; it is the smaller
mov r11, qword [rsp + 8*rdx]
mov qword [rsp + 8*r10], r11
jnz shift_stack_up39
; Fix rsp to point right
; r10 hold the diff between this two pointers
mul_small_stack_loop39:
add rsp, 8
dec r10
jnz mul_small_stack_loop39
jmp fix_n39
enlarge_stack39:
; old_n < new_n
; shift down the stack
mov r8, 1 ; r8 = new_n
add r8, 3 ; r8 = new_stack_size
mov rdx, r8 ; rdx = new_stack_size
mov r8, rbx ; r8 = old_n
add r8, 3 ; r8 = old_stack_size
mov r10, r8 ; r10 = old_stack_size
mov r9, 0
sub rsp, 8 ; we need to take down the hole stack
shift_stack_down39:
; stack[r9] <- stack[r9+1] using r11
mov r11, qword [rsp + 8*(r9+1)]
mov qword [rsp + 8*r9], r11
inc r9
dec r10 ; it is the smaller
jnz shift_stack_down39
; rsp is already fixed
; put in the cleared element NIL
mov qword [rsp + 8*(rdx - 1)], SOB_NIL_ADDRESS
fix_n39:
mov qword [rsp + 2*8], 1
end_of_fix39:
push rbp
mov rbp, rsp
mov rax, qword [rbp + 8 * (4 + 0)]

leave
ret
Lcont39:

mov qword [fvar_tbl + 8*39], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; Applic

mov rax, qword [fvar_tbl + 8*27]

 push rax 
mov rax, qword [fvar_tbl + 8*3]

 push rax 
mov rax, qword [fvar_tbl + 8*4]

 push rax 

 push 3
; LambdaSimple

MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode40)
jmp Lcont40
Lcode40:
push rbp
mov rbp, rsp


mov rax, const_tbl + 23

 push rax 

 push 1
; LambdaSimple

MALLOC rbx, 16 ; rbx = pointer to ExtEnv
mov qword r8, [rbp + 8*2] ; r8 is a pointer to lexical env
; rbx[i+1] <- r8[i] using r9
mov rcx, 0 ; rcx is the loop var
mov rdx, 1
simple_ext_loop41:
mov r9, qword [r8 + 8*rcx]
mov qword [rbx + 8*(rcx+1)], r9
inc rcx
cmp rcx, rdx
jne simple_ext_loop41
mov r10, qword [rbp + 8 * 3] ; r10 is the number of params in previous env
mov r11, r10 ; save the amount of params
shl r10, 3 ; r10 = r10 * 8 - the real size that we should save
MALLOC rdx, r10
mov rcx, 0 ; rcx is the loop var, r11 is the limit, doing the exchange using r14
cmp r11, 0 ; there is no parameters
je simple_param_end_loop41
simple_param_loop41:
mov r14, PVAR(rcx)
mov qword [rdx + 8*(rcx)], r14
inc rcx
cmp rcx, r11
jne simple_param_loop41
simple_param_end_loop41:
mov qword [rbx], rdx ; put this env in ExtEnv[0]
MAKE_CLOSURE(rax, rbx, Lcode41)
jmp Lcont41
Lcode41:
push rbp
mov rbp, rsp


; LambdaSimple

MALLOC rbx, 24 ; rbx = pointer to ExtEnv
mov qword r8, [rbp + 8*2] ; r8 is a pointer to lexical env
; rbx[i+1] <- r8[i] using r9
mov rcx, 0 ; rcx is the loop var
mov rdx, 2
simple_ext_loop42:
mov r9, qword [r8 + 8*rcx]
mov qword [rbx + 8*(rcx+1)], r9
inc rcx
cmp rcx, rdx
jne simple_ext_loop42
mov r10, qword [rbp + 8 * 3] ; r10 is the number of params in previous env
mov r11, r10 ; save the amount of params
shl r10, 3 ; r10 = r10 * 8 - the real size that we should save
MALLOC rdx, r10
mov rcx, 0 ; rcx is the loop var, r11 is the limit, doing the exchange using r14
cmp r11, 0 ; there is no parameters
je simple_param_end_loop42
simple_param_loop42:
mov r14, PVAR(rcx)
mov qword [rdx + 8*(rcx)], r14
inc rcx
cmp rcx, r11
jne simple_param_loop42
simple_param_end_loop42:
mov qword [rbx], rdx ; put this env in ExtEnv[0]
MAKE_CLOSURE(rax, rbx, Lcode42)
jmp Lcont42
Lcode42:
push rbp
mov rbp, rsp

; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*0]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

cmp rax, SOB_FALSE_ADDRESS
jne Lexit43

; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*1]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

cmp rax, SOB_FALSE_ADDRESS
je Lelse44

; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*2]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 

 push 1
mov rax, qword [fvar_tbl + 8*40]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
push qword[ rbp + 8 ] ;;old ret address)
push qword[rbp]    ;;backup old rbp
mov r9, qword[rbp + 8*3]  ;;get old args num
add r9, 4
shl r9, 3             ;;set new r9 = (x+4)*8
;;fix the stack
SHIFT_FRAME 5    ;;args_count + 4 = n + env + ret addrs +old rbp
add rsp, r9            ;;set new stack pointer
pop rbp            ;;restore old rbp
jmp qword[rax + 1 + 8] ;;jmp to code (rax is all the closure, skip tag = +1, skip env = +8)

jmp Lexit45
Lelse44:

mov rax, const_tbl + 2

Lexit45:

Lexit43:

leave
ret
Lcont42:

mov qword [rbp + 8 * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
mov rax, qword [rbp + 8 * (4 + 0)]

leave
ret
Lcont41:

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
push qword[ rbp + 8 ] ;;old ret address)
push qword[rbp]    ;;backup old rbp
mov r9, qword[rbp + 8*3]  ;;get old args num
add r9, 4
shl r9, 3             ;;set new r9 = (x+4)*8
;;fix the stack
SHIFT_FRAME 5    ;;args_count + 4 = n + env + ret addrs +old rbp
add rsp, r9            ;;set new stack pointer
pop rbp            ;;restore old rbp
jmp qword[rax + 1 + 8] ;;jmp to code (rax is all the closure, skip tag = +1, skip env = +8)

leave
ret
Lcont40:

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

mov qword [fvar_tbl + 8*40], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; Applic

mov rax, qword [fvar_tbl + 8*12]

 push rax 
mov rax, qword [fvar_tbl + 8*26]

 push rax 
mov rax, qword [fvar_tbl + 8*4]

 push rax 

 push 3
; LambdaSimple

MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode46)
jmp Lcont46
Lcode46:
push rbp
mov rbp, rsp
; LambdaOpt

MALLOC rbx, 16 ; rbx = pointer to ExtEnv
mov qword r8, [rbp + 8*2] ; r8 is a pointer to lexical env
; rbx[i+1] <- r8[i] using r9
mov rcx, 0 ; rcx is the loop var
mov rdx, 1
simple_ext_loop47:
mov r9, qword [r8 + 8*rcx]
mov qword [rbx + 8*(rcx+1)], r9
inc rcx
cmp rcx, rdx
jne simple_ext_loop47
mov r10, qword [rbp + 8 * 3] ; r10 is the number of params in previous env
mov r11, r10 ; save the amount of params
shl r10, 3 ; r10 = r10 * 8 - the real size that we should save
MALLOC rdx, r10
mov rcx, 0 ; rcx is the loop var, r11 is the limit, doing the exchange using r14
cmp r11, 0 ; there is no parameters
je simple_param_end_loop47
simple_param_loop47:
mov r14, PVAR(rcx)
mov qword [rdx + 8*(rcx)], r14
inc rcx
cmp rcx, r11
jne simple_param_loop47
simple_param_end_loop47:
mov qword [rbx], rdx ; put this env in ExtEnv[0]
MAKE_CLOSURE(rax, rbx, Lcode47)
jmp Lcont47
Lcode47:
; Adjust the stack for the optional arguments
mov rbx, qword [rsp + 8*2] ; rbx = actual_n
cmp rbx, 2
jne not_eq47
mov r8, qword [rsp + 8*(2 + rbx)]
mov r10, r8 ; r10 = address of element
MAKE_PAIR (r9, r10, SOB_NIL_ADDRESS) ; r9 = Pair(r10, Nil)
mov qword [rsp + 8*(2 + rbx)], r9 ; stack[n-1] = Pair(element, Nil)
jmp end_of_fix47
not_eq47:
; rbx have the actual n
cmp rbx, 2
jl enlarge_stack47
; new_n < old_n
; create list of rest element
mov rcx, rbx
sub rcx, 2
inc rcx ; Need to Pair the last element as well
mov r9, SOB_NIL_ADDRESS
pair_cons_loop47:
; rcx is the loop counter
; r8 = element from the end of stack to the position of the pair
mov r8, qword [rsp + 8*(2 + 2 + rcx - 1)]
MAKE_PAIR (rdx, r8, r9) ; rdx = Pair(r8, r9)
; update r9
mov r9, rdx
dec rcx
jnz pair_cons_loop47
; r9 has the list
mov qword [rsp + 8 * (2 + 2)], r9
; adjust the stack size from n to 2
mov r8, 2 ; r8 = new_n
add r8, 3 ; r8 = new_stack_size
; We want that rdx will point to the last element
mov rdx, r8
; We want that r10 will point to the last element of old stack
mov r8, rbx ; r8 = old_n
add r8, 3 ; r8 = old_stack_size
mov r10, r8
shift_stack_up47:
; stack[r10-1] <- stack[rdx-1] using r11
dec r10
dec rdx ; it is the smaller
mov r11, qword [rsp + 8*rdx]
mov qword [rsp + 8*r10], r11
jnz shift_stack_up47
; Fix rsp to point right
; r10 hold the diff between this two pointers
mul_small_stack_loop47:
add rsp, 8
dec r10
jnz mul_small_stack_loop47
jmp fix_n47
enlarge_stack47:
; old_n < new_n
; shift down the stack
mov r8, 2 ; r8 = new_n
add r8, 3 ; r8 = new_stack_size
mov rdx, r8 ; rdx = new_stack_size
mov r8, rbx ; r8 = old_n
add r8, 3 ; r8 = old_stack_size
mov r10, r8 ; r10 = old_stack_size
mov r9, 0
sub rsp, 8 ; we need to take down the hole stack
shift_stack_down47:
; stack[r9] <- stack[r9+1] using r11
mov r11, qword [rsp + 8*(r9+1)]
mov qword [rsp + 8*r9], r11
inc r9
dec r10 ; it is the smaller
jnz shift_stack_down47
; rsp is already fixed
; put in the cleared element NIL
mov qword [rsp + 8*(rdx - 1)], SOB_NIL_ADDRESS
fix_n47:
mov qword [rsp + 2*8], 2
end_of_fix47:
push rbp
mov rbp, rsp

; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0]
mov rax, qword [rax + 8*0]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

cmp rax, SOB_FALSE_ADDRESS
je Lelse48


mov rax, const_tbl + 49

 push rax 
mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 

 push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0]
mov rax, qword [rax + 8*2]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
push qword[ rbp + 8 ] ;;old ret address)
push qword[rbp]    ;;backup old rbp
mov r9, qword[rbp + 8*3]  ;;get old args num
add r9, 4
shl r9, 3             ;;set new r9 = (x+4)*8
;;fix the stack
SHIFT_FRAME 6    ;;args_count + 4 = n + env + ret addrs +old rbp
add rsp, r9            ;;set new stack pointer
pop rbp            ;;restore old rbp
jmp qword[rax + 1 + 8] ;;jmp to code (rax is all the closure, skip tag = +1, skip env = +8)

jmp Lexit49
Lelse48:

; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0]
mov rax, qword [rax + 8*1]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 
mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 

 push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0]
mov rax, qword [rax + 8*2]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
push qword[ rbp + 8 ] ;;old ret address)
push qword[rbp]    ;;backup old rbp
mov r9, qword[rbp + 8*3]  ;;get old args num
add r9, 4
shl r9, 3             ;;set new r9 = (x+4)*8
;;fix the stack
SHIFT_FRAME 6    ;;args_count + 4 = n + env + ret addrs +old rbp
add rsp, r9            ;;set new stack pointer
pop rbp            ;;restore old rbp
jmp qword[rax + 1 + 8] ;;jmp to code (rax is all the closure, skip tag = +1, skip env = +8)

Lexit49:

leave
ret
Lcont47:

leave
ret
Lcont46:

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

mov qword [fvar_tbl + 8*12], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; LambdaSimple

MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode50)
jmp Lcont50
Lcode50:
push rbp
mov rbp, rsp

mov rax, qword [rbp + 8 * (4 + 0)]

cmp rax, SOB_FALSE_ADDRESS
je Lelse51

mov rax, const_tbl + 2

jmp Lexit52
Lelse51:

mov rax, const_tbl + 4

Lexit52:

leave
ret
Lcont50:

mov qword [fvar_tbl + 8*41], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; Applic

mov rax, qword [fvar_tbl + 8*4]

 push rax 
mov rax, qword [fvar_tbl + 8*27]

 push rax 
mov rax, qword [fvar_tbl + 8*26]

 push rax 
mov rax, qword [fvar_tbl + 8*22]

 push rax 
mov rax, qword [fvar_tbl + 8*21]

 push rax 
mov rax, qword [fvar_tbl + 8*20]

 push rax 
mov rax, qword [fvar_tbl + 8*19]

 push rax 
mov rax, qword [fvar_tbl + 8*18]

 push rax 
mov rax, qword [fvar_tbl + 8*32]

 push rax 
mov rax, qword [fvar_tbl + 8*33]

 push rax 
mov rax, qword [fvar_tbl + 8*16]

 push rax 
mov rax, qword [fvar_tbl + 8*2]

 push rax 
mov rax, qword [fvar_tbl + 8*1]

 push rax 

 push 13
; LambdaSimple

MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode53)
jmp Lcont53
Lcode53:
push rbp
mov rbp, rsp

; LambdaSimple

MALLOC rbx, 16 ; rbx = pointer to ExtEnv
mov qword r8, [rbp + 8*2] ; r8 is a pointer to lexical env
; rbx[i+1] <- r8[i] using r9
mov rcx, 0 ; rcx is the loop var
mov rdx, 1
simple_ext_loop54:
mov r9, qword [r8 + 8*rcx]
mov qword [rbx + 8*(rcx+1)], r9
inc rcx
cmp rcx, rdx
jne simple_ext_loop54
mov r10, qword [rbp + 8 * 3] ; r10 is the number of params in previous env
mov r11, r10 ; save the amount of params
shl r10, 3 ; r10 = r10 * 8 - the real size that we should save
MALLOC rdx, r10
mov rcx, 0 ; rcx is the loop var, r11 is the limit, doing the exchange using r14
cmp r11, 0 ; there is no parameters
je simple_param_end_loop54
simple_param_loop54:
mov r14, PVAR(rcx)
mov qword [rdx + 8*(rcx)], r14
inc rcx
cmp rcx, r11
jne simple_param_loop54
simple_param_end_loop54:
mov qword [rbx], rdx ; put this env in ExtEnv[0]
MAKE_CLOSURE(rax, rbx, Lcode54)
jmp Lcont54
Lcode54:
push rbp
mov rbp, rsp
; LambdaSimple

MALLOC rbx, 24 ; rbx = pointer to ExtEnv
mov qword r8, [rbp + 8*2] ; r8 is a pointer to lexical env
; rbx[i+1] <- r8[i] using r9
mov rcx, 0 ; rcx is the loop var
mov rdx, 2
simple_ext_loop55:
mov r9, qword [r8 + 8*rcx]
mov qword [rbx + 8*(rcx+1)], r9
inc rcx
cmp rcx, rdx
jne simple_ext_loop55
mov r10, qword [rbp + 8 * 3] ; r10 is the number of params in previous env
mov r11, r10 ; save the amount of params
shl r10, 3 ; r10 = r10 * 8 - the real size that we should save
MALLOC rdx, r10
mov rcx, 0 ; rcx is the loop var, r11 is the limit, doing the exchange using r14
cmp r11, 0 ; there is no parameters
je simple_param_end_loop55
simple_param_loop55:
mov r14, PVAR(rcx)
mov qword [rdx + 8*(rcx)], r14
inc rcx
cmp rcx, r11
jne simple_param_loop55
simple_param_end_loop55:
mov qword [rbx], rdx ; put this env in ExtEnv[0]
MAKE_CLOSURE(rax, rbx, Lcode55)
jmp Lcont55
Lcode55:
push rbp
mov rbp, rsp


; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*0]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

cmp rax, SOB_FALSE_ADDRESS
je Lelse62
; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*1]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

jmp Lexit63
Lelse62:

mov rax, const_tbl + 2

Lexit63:

cmp rax, SOB_FALSE_ADDRESS
je Lelse56

; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*2]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 
mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 

 push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0]
mov rax, qword [rax + 8*0]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
push qword[ rbp + 8 ] ;;old ret address)
push qword[rbp]    ;;backup old rbp
mov r9, qword[rbp + 8*3]  ;;get old args num
add r9, 4
shl r9, 3             ;;set new r9 = (x+4)*8
;;fix the stack
SHIFT_FRAME 6    ;;args_count + 4 = n + env + ret addrs +old rbp
add rsp, r9            ;;set new stack pointer
pop rbp            ;;restore old rbp
jmp qword[rax + 1 + 8] ;;jmp to code (rax is all the closure, skip tag = +1, skip env = +8)

jmp Lexit57
Lelse56:


; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*1]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

cmp rax, SOB_FALSE_ADDRESS
je Lelse60
; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*0]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

jmp Lexit61
Lelse60:

mov rax, const_tbl + 2

Lexit61:

cmp rax, SOB_FALSE_ADDRESS
je Lelse58

mov rax, qword [rbp + 8 * (4 + 1)]

 push rax 
; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*2]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 

 push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0]
mov rax, qword [rax + 8*0]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
push qword[ rbp + 8 ] ;;old ret address)
push qword[rbp]    ;;backup old rbp
mov r9, qword[rbp + 8*3]  ;;get old args num
add r9, 4
shl r9, 3             ;;set new r9 = (x+4)*8
;;fix the stack
SHIFT_FRAME 6    ;;args_count + 4 = n + env + ret addrs +old rbp
add rsp, r9            ;;set new stack pointer
pop rbp            ;;restore old rbp
jmp qword[rax + 1 + 8] ;;jmp to code (rax is all the closure, skip tag = +1, skip env = +8)

jmp Lexit59
Lelse58:

mov rax, qword [rbp + 8 * (4 + 1)]

 push rax 
mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 

 push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0]
mov rax, qword [rax + 8*0]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
push qword[ rbp + 8 ] ;;old ret address)
push qword[rbp]    ;;backup old rbp
mov r9, qword[rbp + 8*3]  ;;get old args num
add r9, 4
shl r9, 3             ;;set new r9 = (x+4)*8
;;fix the stack
SHIFT_FRAME 6    ;;args_count + 4 = n + env + ret addrs +old rbp
add rsp, r9            ;;set new stack pointer
pop rbp            ;;restore old rbp
jmp qword[rax + 1 + 8] ;;jmp to code (rax is all the closure, skip tag = +1, skip env = +8)

Lexit59:

Lexit57:

leave
ret
Lcont55:

leave
ret
Lcont54:

 push rax 

 push 1
; LambdaSimple

MALLOC rbx, 16 ; rbx = pointer to ExtEnv
mov qword r8, [rbp + 8*2] ; r8 is a pointer to lexical env
; rbx[i+1] <- r8[i] using r9
mov rcx, 0 ; rcx is the loop var
mov rdx, 1
simple_ext_loop64:
mov r9, qword [r8 + 8*rcx]
mov qword [rbx + 8*(rcx+1)], r9
inc rcx
cmp rcx, rdx
jne simple_ext_loop64
mov r10, qword [rbp + 8 * 3] ; r10 is the number of params in previous env
mov r11, r10 ; save the amount of params
shl r10, 3 ; r10 = r10 * 8 - the real size that we should save
MALLOC rdx, r10
mov rcx, 0 ; rcx is the loop var, r11 is the limit, doing the exchange using r14
cmp r11, 0 ; there is no parameters
je simple_param_end_loop64
simple_param_loop64:
mov r14, PVAR(rcx)
mov qword [rdx + 8*(rcx)], r14
inc rcx
cmp rcx, r11
jne simple_param_loop64
simple_param_end_loop64:
mov qword [rbx], rdx ; put this env in ExtEnv[0]
MAKE_CLOSURE(rax, rbx, Lcode64)
jmp Lcont64
Lcode64:
push rbp
mov rbp, rsp

; Applic

; LambdaSimple

MALLOC rbx, 24 ; rbx = pointer to ExtEnv
mov qword r8, [rbp + 8*2] ; r8 is a pointer to lexical env
; rbx[i+1] <- r8[i] using r9
mov rcx, 0 ; rcx is the loop var
mov rdx, 2
simple_ext_loop65:
mov r9, qword [r8 + 8*rcx]
mov qword [rbx + 8*(rcx+1)], r9
inc rcx
cmp rcx, rdx
jne simple_ext_loop65
mov r10, qword [rbp + 8 * 3] ; r10 is the number of params in previous env
mov r11, r10 ; save the amount of params
shl r10, 3 ; r10 = r10 * 8 - the real size that we should save
MALLOC rdx, r10
mov rcx, 0 ; rcx is the loop var, r11 is the limit, doing the exchange using r14
cmp r11, 0 ; there is no parameters
je simple_param_end_loop65
simple_param_loop65:
mov r14, PVAR(rcx)
mov qword [rdx + 8*(rcx)], r14
inc rcx
cmp rcx, r11
jne simple_param_loop65
simple_param_end_loop65:
mov qword [rbx], rdx ; put this env in ExtEnv[0]
MAKE_CLOSURE(rax, rbx, Lcode65)
jmp Lcont65
Lcode65:
push rbp
mov rbp, rsp

; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*0]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

cmp rax, SOB_FALSE_ADDRESS
je Lelse66
mov rax, qword [rbp + 8 * (4 + 0)]

jmp Lexit67
Lelse66:

; Applic

; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 

 push 1
mov rax, qword [fvar_tbl + 8*24]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 
; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 

 push 1
mov rax, qword [fvar_tbl + 8*23]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 

 push 2
mov rax, qword [fvar_tbl + 8*25]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 

 push 1
; LambdaSimple

MALLOC rbx, 32 ; rbx = pointer to ExtEnv
mov qword r8, [rbp + 8*2] ; r8 is a pointer to lexical env
; rbx[i+1] <- r8[i] using r9
mov rcx, 0 ; rcx is the loop var
mov rdx, 3
simple_ext_loop68:
mov r9, qword [r8 + 8*rcx]
mov qword [rbx + 8*(rcx+1)], r9
inc rcx
cmp rcx, rdx
jne simple_ext_loop68
mov r10, qword [rbp + 8 * 3] ; r10 is the number of params in previous env
mov r11, r10 ; save the amount of params
shl r10, 3 ; r10 = r10 * 8 - the real size that we should save
MALLOC rdx, r10
mov rcx, 0 ; rcx is the loop var, r11 is the limit, doing the exchange using r14
cmp r11, 0 ; there is no parameters
je simple_param_end_loop68
simple_param_loop68:
mov r14, PVAR(rcx)
mov qword [rdx + 8*(rcx)], r14
inc rcx
cmp rcx, r11
jne simple_param_loop68
simple_param_end_loop68:
mov qword [rbx], rdx ; put this env in ExtEnv[0]
MAKE_CLOSURE(rax, rbx, Lcode68)
jmp Lcont68
Lcode68:
push rbp
mov rbp, rsp

; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 
; Applic

mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0]
mov rax, qword [rax + 8*0]

 push rax 

 push 1
mov rax, qword [fvar_tbl + 8*24]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 

 push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*2]
mov rax, qword [rax + 8*7]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 
; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 
; Applic

mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0]
mov rax, qword [rax + 8*0]

 push rax 

 push 1
mov rax, qword [fvar_tbl + 8*23]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 

 push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*2]
mov rax, qword [rax + 8*7]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 

 push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*2]
mov rax, qword [rax + 8*7]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
push qword[ rbp + 8 ] ;;old ret address)
push qword[rbp]    ;;backup old rbp
mov r9, qword[rbp + 8*3]  ;;get old args num
add r9, 4
shl r9, 3             ;;set new r9 = (x+4)*8
;;fix the stack
SHIFT_FRAME 6    ;;args_count + 4 = n + env + ret addrs +old rbp
add rsp, r9            ;;set new stack pointer
pop rbp            ;;restore old rbp
jmp qword[rax + 1 + 8] ;;jmp to code (rax is all the closure, skip tag = +1, skip env = +8)

leave
ret
Lcont68:

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
push qword[ rbp + 8 ] ;;old ret address)
push qword[rbp]    ;;backup old rbp
mov r9, qword[rbp + 8*3]  ;;get old args num
add r9, 4
shl r9, 3             ;;set new r9 = (x+4)*8
;;fix the stack
SHIFT_FRAME 5    ;;args_count + 4 = n + env + ret addrs +old rbp
add rsp, r9            ;;set new stack pointer
pop rbp            ;;restore old rbp
jmp qword[rax + 1 + 8] ;;jmp to code (rax is all the closure, skip tag = +1, skip env = +8)

Lexit67:

leave
ret
Lcont65:

 push rax 

 push 1
; LambdaSimple

MALLOC rbx, 24 ; rbx = pointer to ExtEnv
mov qword r8, [rbp + 8*2] ; r8 is a pointer to lexical env
; rbx[i+1] <- r8[i] using r9
mov rcx, 0 ; rcx is the loop var
mov rdx, 2
simple_ext_loop69:
mov r9, qword [r8 + 8*rcx]
mov qword [rbx + 8*(rcx+1)], r9
inc rcx
cmp rcx, rdx
jne simple_ext_loop69
mov r10, qword [rbp + 8 * 3] ; r10 is the number of params in previous env
mov r11, r10 ; save the amount of params
shl r10, 3 ; r10 = r10 * 8 - the real size that we should save
MALLOC rdx, r10
mov rcx, 0 ; rcx is the loop var, r11 is the limit, doing the exchange using r14
cmp r11, 0 ; there is no parameters
je simple_param_end_loop69
simple_param_loop69:
mov r14, PVAR(rcx)
mov qword [rdx + 8*(rcx)], r14
inc rcx
cmp rcx, r11
jne simple_param_loop69
simple_param_end_loop69:
mov qword [rbx], rdx ; put this env in ExtEnv[0]
MAKE_CLOSURE(rax, rbx, Lcode69)
jmp Lcont69
Lcode69:
push rbp
mov rbp, rsp


; LambdaOpt

MALLOC rbx, 32 ; rbx = pointer to ExtEnv
mov qword r8, [rbp + 8*2] ; r8 is a pointer to lexical env
; rbx[i+1] <- r8[i] using r9
mov rcx, 0 ; rcx is the loop var
mov rdx, 3
simple_ext_loop70:
mov r9, qword [r8 + 8*rcx]
mov qword [rbx + 8*(rcx+1)], r9
inc rcx
cmp rcx, rdx
jne simple_ext_loop70
mov r10, qword [rbp + 8 * 3] ; r10 is the number of params in previous env
mov r11, r10 ; save the amount of params
shl r10, 3 ; r10 = r10 * 8 - the real size that we should save
MALLOC rdx, r10
mov rcx, 0 ; rcx is the loop var, r11 is the limit, doing the exchange using r14
cmp r11, 0 ; there is no parameters
je simple_param_end_loop70
simple_param_loop70:
mov r14, PVAR(rcx)
mov qword [rdx + 8*(rcx)], r14
inc rcx
cmp rcx, r11
jne simple_param_loop70
simple_param_end_loop70:
mov qword [rbx], rdx ; put this env in ExtEnv[0]
MAKE_CLOSURE(rax, rbx, Lcode70)
jmp Lcont70
Lcode70:
; Adjust the stack for the optional arguments
mov rbx, qword [rsp + 8*2] ; rbx = actual_n
cmp rbx, 1
jne not_eq70
mov r8, qword [rsp + 8*(2 + rbx)]
mov r10, r8 ; r10 = address of element
MAKE_PAIR (r9, r10, SOB_NIL_ADDRESS) ; r9 = Pair(r10, Nil)
mov qword [rsp + 8*(2 + rbx)], r9 ; stack[n-1] = Pair(element, Nil)
jmp end_of_fix70
not_eq70:
; rbx have the actual n
cmp rbx, 1
jl enlarge_stack70
; new_n < old_n
; create list of rest element
mov rcx, rbx
sub rcx, 1
inc rcx ; Need to Pair the last element as well
mov r9, SOB_NIL_ADDRESS
pair_cons_loop70:
; rcx is the loop counter
; r8 = element from the end of stack to the position of the pair
mov r8, qword [rsp + 8*(2 + 1 + rcx - 1)]
MAKE_PAIR (rdx, r8, r9) ; rdx = Pair(r8, r9)
; update r9
mov r9, rdx
dec rcx
jnz pair_cons_loop70
; r9 has the list
mov qword [rsp + 8 * (2 + 1)], r9
; adjust the stack size from n to 1
mov r8, 1 ; r8 = new_n
add r8, 3 ; r8 = new_stack_size
; We want that rdx will point to the last element
mov rdx, r8
; We want that r10 will point to the last element of old stack
mov r8, rbx ; r8 = old_n
add r8, 3 ; r8 = old_stack_size
mov r10, r8
shift_stack_up70:
; stack[r10-1] <- stack[rdx-1] using r11
dec r10
dec rdx ; it is the smaller
mov r11, qword [rsp + 8*rdx]
mov qword [rsp + 8*r10], r11
jnz shift_stack_up70
; Fix rsp to point right
; r10 hold the diff between this two pointers
mul_small_stack_loop70:
add rsp, 8
dec r10
jnz mul_small_stack_loop70
jmp fix_n70
enlarge_stack70:
; old_n < new_n
; shift down the stack
mov r8, 1 ; r8 = new_n
add r8, 3 ; r8 = new_stack_size
mov rdx, r8 ; rdx = new_stack_size
mov r8, rbx ; r8 = old_n
add r8, 3 ; r8 = old_stack_size
mov r10, r8 ; r10 = old_stack_size
mov r9, 0
sub rsp, 8 ; we need to take down the hole stack
shift_stack_down70:
; stack[r9] <- stack[r9+1] using r11
mov r11, qword [rsp + 8*(r9+1)]
mov qword [rsp + 8*r9], r11
inc r9
dec r10 ; it is the smaller
jnz shift_stack_down70
; rsp is already fixed
; put in the cleared element NIL
mov qword [rsp + 8*(rdx - 1)], SOB_NIL_ADDRESS
fix_n70:
mov qword [rsp + 2*8], 1
end_of_fix70:
push rbp
mov rbp, rsp

; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 

mov rax, const_tbl + 51

 push rax 
; Applic

mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*2]
mov rax, qword [rax + 8*5]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*0]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 

 push 3
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*2]
mov rax, qword [rax + 8*3]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0]
mov rax, qword [rax + 8*0]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
push qword[ rbp + 8 ] ;;old ret address)
push qword[rbp]    ;;backup old rbp
mov r9, qword[rbp + 8*3]  ;;get old args num
add r9, 4
shl r9, 3             ;;set new r9 = (x+4)*8
;;fix the stack
SHIFT_FRAME 5    ;;args_count + 4 = n + env + ret addrs +old rbp
add rsp, r9            ;;set new stack pointer
pop rbp            ;;restore old rbp
jmp qword[rax + 1 + 8] ;;jmp to code (rax is all the closure, skip tag = +1, skip env = +8)

leave
ret
Lcont70:
mov qword [fvar_tbl + 8*18], rax
mov rax, SOB_VOID_ADDRESS

; LambdaOpt

MALLOC rbx, 32 ; rbx = pointer to ExtEnv
mov qword r8, [rbp + 8*2] ; r8 is a pointer to lexical env
; rbx[i+1] <- r8[i] using r9
mov rcx, 0 ; rcx is the loop var
mov rdx, 3
simple_ext_loop71:
mov r9, qword [r8 + 8*rcx]
mov qword [rbx + 8*(rcx+1)], r9
inc rcx
cmp rcx, rdx
jne simple_ext_loop71
mov r10, qword [rbp + 8 * 3] ; r10 is the number of params in previous env
mov r11, r10 ; save the amount of params
shl r10, 3 ; r10 = r10 * 8 - the real size that we should save
MALLOC rdx, r10
mov rcx, 0 ; rcx is the loop var, r11 is the limit, doing the exchange using r14
cmp r11, 0 ; there is no parameters
je simple_param_end_loop71
simple_param_loop71:
mov r14, PVAR(rcx)
mov qword [rdx + 8*(rcx)], r14
inc rcx
cmp rcx, r11
jne simple_param_loop71
simple_param_end_loop71:
mov qword [rbx], rdx ; put this env in ExtEnv[0]
MAKE_CLOSURE(rax, rbx, Lcode71)
jmp Lcont71
Lcode71:
; Adjust the stack for the optional arguments
mov rbx, qword [rsp + 8*2] ; rbx = actual_n
cmp rbx, 1
jne not_eq71
mov r8, qword [rsp + 8*(2 + rbx)]
mov r10, r8 ; r10 = address of element
MAKE_PAIR (r9, r10, SOB_NIL_ADDRESS) ; r9 = Pair(r10, Nil)
mov qword [rsp + 8*(2 + rbx)], r9 ; stack[n-1] = Pair(element, Nil)
jmp end_of_fix71
not_eq71:
; rbx have the actual n
cmp rbx, 1
jl enlarge_stack71
; new_n < old_n
; create list of rest element
mov rcx, rbx
sub rcx, 1
inc rcx ; Need to Pair the last element as well
mov r9, SOB_NIL_ADDRESS
pair_cons_loop71:
; rcx is the loop counter
; r8 = element from the end of stack to the position of the pair
mov r8, qword [rsp + 8*(2 + 1 + rcx - 1)]
MAKE_PAIR (rdx, r8, r9) ; rdx = Pair(r8, r9)
; update r9
mov r9, rdx
dec rcx
jnz pair_cons_loop71
; r9 has the list
mov qword [rsp + 8 * (2 + 1)], r9
; adjust the stack size from n to 1
mov r8, 1 ; r8 = new_n
add r8, 3 ; r8 = new_stack_size
; We want that rdx will point to the last element
mov rdx, r8
; We want that r10 will point to the last element of old stack
mov r8, rbx ; r8 = old_n
add r8, 3 ; r8 = old_stack_size
mov r10, r8
shift_stack_up71:
; stack[r10-1] <- stack[rdx-1] using r11
dec r10
dec rdx ; it is the smaller
mov r11, qword [rsp + 8*rdx]
mov qword [rsp + 8*r10], r11
jnz shift_stack_up71
; Fix rsp to point right
; r10 hold the diff between this two pointers
mul_small_stack_loop71:
add rsp, 8
dec r10
jnz mul_small_stack_loop71
jmp fix_n71
enlarge_stack71:
; old_n < new_n
; shift down the stack
mov r8, 1 ; r8 = new_n
add r8, 3 ; r8 = new_stack_size
mov rdx, r8 ; rdx = new_stack_size
mov r8, rbx ; r8 = old_n
add r8, 3 ; r8 = old_stack_size
mov r10, r8 ; r10 = old_stack_size
mov r9, 0
sub rsp, 8 ; we need to take down the hole stack
shift_stack_down71:
; stack[r9] <- stack[r9+1] using r11
mov r11, qword [rsp + 8*(r9+1)]
mov qword [rsp + 8*r9], r11
inc r9
dec r10 ; it is the smaller
jnz shift_stack_down71
; rsp is already fixed
; put in the cleared element NIL
mov qword [rsp + 8*(rdx - 1)], SOB_NIL_ADDRESS
fix_n71:
mov qword [rsp + 2*8], 1
end_of_fix71:
push rbp
mov rbp, rsp

; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 

mov rax, const_tbl + 32

 push rax 
; Applic

mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*2]
mov rax, qword [rax + 8*6]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*0]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 

 push 3
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*2]
mov rax, qword [rax + 8*3]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0]
mov rax, qword [rax + 8*0]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
push qword[ rbp + 8 ] ;;old ret address)
push qword[rbp]    ;;backup old rbp
mov r9, qword[rbp + 8*3]  ;;get old args num
add r9, 4
shl r9, 3             ;;set new r9 = (x+4)*8
;;fix the stack
SHIFT_FRAME 5    ;;args_count + 4 = n + env + ret addrs +old rbp
add rsp, r9            ;;set new stack pointer
pop rbp            ;;restore old rbp
jmp qword[rax + 1 + 8] ;;jmp to code (rax is all the closure, skip tag = +1, skip env = +8)

leave
ret
Lcont71:
mov qword [fvar_tbl + 8*19], rax
mov rax, SOB_VOID_ADDRESS

; Applic

; Applic

mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*7]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0]
mov rax, qword [rax + 8*0]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 

 push 1
; LambdaSimple

MALLOC rbx, 32 ; rbx = pointer to ExtEnv
mov qword r8, [rbp + 8*2] ; r8 is a pointer to lexical env
; rbx[i+1] <- r8[i] using r9
mov rcx, 0 ; rcx is the loop var
mov rdx, 3
simple_ext_loop72:
mov r9, qword [r8 + 8*rcx]
mov qword [rbx + 8*(rcx+1)], r9
inc rcx
cmp rcx, rdx
jne simple_ext_loop72
mov r10, qword [rbp + 8 * 3] ; r10 is the number of params in previous env
mov r11, r10 ; save the amount of params
shl r10, 3 ; r10 = r10 * 8 - the real size that we should save
MALLOC rdx, r10
mov rcx, 0 ; rcx is the loop var, r11 is the limit, doing the exchange using r14
cmp r11, 0 ; there is no parameters
je simple_param_end_loop72
simple_param_loop72:
mov r14, PVAR(rcx)
mov qword [rdx + 8*(rcx)], r14
inc rcx
cmp rcx, r11
jne simple_param_loop72
simple_param_end_loop72:
mov qword [rbx], rdx ; put this env in ExtEnv[0]
MAKE_CLOSURE(rax, rbx, Lcode72)
jmp Lcont72
Lcode72:
push rbp
mov rbp, rsp
; LambdaOpt

MALLOC rbx, 40 ; rbx = pointer to ExtEnv
mov qword r8, [rbp + 8*2] ; r8 is a pointer to lexical env
; rbx[i+1] <- r8[i] using r9
mov rcx, 0 ; rcx is the loop var
mov rdx, 4
simple_ext_loop73:
mov r9, qword [r8 + 8*rcx]
mov qword [rbx + 8*(rcx+1)], r9
inc rcx
cmp rcx, rdx
jne simple_ext_loop73
mov r10, qword [rbp + 8 * 3] ; r10 is the number of params in previous env
mov r11, r10 ; save the amount of params
shl r10, 3 ; r10 = r10 * 8 - the real size that we should save
MALLOC rdx, r10
mov rcx, 0 ; rcx is the loop var, r11 is the limit, doing the exchange using r14
cmp r11, 0 ; there is no parameters
je simple_param_end_loop73
simple_param_loop73:
mov r14, PVAR(rcx)
mov qword [rdx + 8*(rcx)], r14
inc rcx
cmp rcx, r11
jne simple_param_loop73
simple_param_end_loop73:
mov qword [rbx], rdx ; put this env in ExtEnv[0]
MAKE_CLOSURE(rax, rbx, Lcode73)
jmp Lcont73
Lcode73:
; Adjust the stack for the optional arguments
mov rbx, qword [rsp + 8*2] ; rbx = actual_n
cmp rbx, 2
jne not_eq73
mov r8, qword [rsp + 8*(2 + rbx)]
mov r10, r8 ; r10 = address of element
MAKE_PAIR (r9, r10, SOB_NIL_ADDRESS) ; r9 = Pair(r10, Nil)
mov qword [rsp + 8*(2 + rbx)], r9 ; stack[n-1] = Pair(element, Nil)
jmp end_of_fix73
not_eq73:
; rbx have the actual n
cmp rbx, 2
jl enlarge_stack73
; new_n < old_n
; create list of rest element
mov rcx, rbx
sub rcx, 2
inc rcx ; Need to Pair the last element as well
mov r9, SOB_NIL_ADDRESS
pair_cons_loop73:
; rcx is the loop counter
; r8 = element from the end of stack to the position of the pair
mov r8, qword [rsp + 8*(2 + 2 + rcx - 1)]
MAKE_PAIR (rdx, r8, r9) ; rdx = Pair(r8, r9)
; update r9
mov r9, rdx
dec rcx
jnz pair_cons_loop73
; r9 has the list
mov qword [rsp + 8 * (2 + 2)], r9
; adjust the stack size from n to 2
mov r8, 2 ; r8 = new_n
add r8, 3 ; r8 = new_stack_size
; We want that rdx will point to the last element
mov rdx, r8
; We want that r10 will point to the last element of old stack
mov r8, rbx ; r8 = old_n
add r8, 3 ; r8 = old_stack_size
mov r10, r8
shift_stack_up73:
; stack[r10-1] <- stack[rdx-1] using r11
dec r10
dec rdx ; it is the smaller
mov r11, qword [rsp + 8*rdx]
mov qword [rsp + 8*r10], r11
jnz shift_stack_up73
; Fix rsp to point right
; r10 hold the diff between this two pointers
mul_small_stack_loop73:
add rsp, 8
dec r10
jnz mul_small_stack_loop73
jmp fix_n73
enlarge_stack73:
; old_n < new_n
; shift down the stack
mov r8, 2 ; r8 = new_n
add r8, 3 ; r8 = new_stack_size
mov rdx, r8 ; rdx = new_stack_size
mov r8, rbx ; r8 = old_n
add r8, 3 ; r8 = old_stack_size
mov r10, r8 ; r10 = old_stack_size
mov r9, 0
sub rsp, 8 ; we need to take down the hole stack
shift_stack_down73:
; stack[r9] <- stack[r9+1] using r11
mov r11, qword [rsp + 8*(r9+1)]
mov qword [rsp + 8*r9], r11
inc r9
dec r10 ; it is the smaller
jnz shift_stack_down73
; rsp is already fixed
; put in the cleared element NIL
mov qword [rsp + 8*(rdx - 1)], SOB_NIL_ADDRESS
fix_n73:
mov qword [rsp + 2*8], 2
end_of_fix73:
push rbp
mov rbp, rsp

; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*3]
mov rax, qword [rax + 8*12]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

cmp rax, SOB_FALSE_ADDRESS
je Lelse74

mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 

mov rax, const_tbl + 32

 push rax 

 push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0]
mov rax, qword [rax + 8*0]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
push qword[ rbp + 8 ] ;;old ret address)
push qword[rbp]    ;;backup old rbp
mov r9, qword[rbp + 8*3]  ;;get old args num
add r9, 4
shl r9, 3             ;;set new r9 = (x+4)*8
;;fix the stack
SHIFT_FRAME 6    ;;args_count + 4 = n + env + ret addrs +old rbp
add rsp, r9            ;;set new stack pointer
pop rbp            ;;restore old rbp
jmp qword[rax + 1 + 8] ;;jmp to code (rax is all the closure, skip tag = +1, skip env = +8)

jmp Lexit75
Lelse74:

; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

 push rax 
mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0]
mov rax, qword [rax + 8*0]

 push rax 

 push 3
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*3]
mov rax, qword [rax + 8*3]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*0]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
push qword[ rbp + 8 ] ;;old ret address)
push qword[rbp]    ;;backup old rbp
mov r9, qword[rbp + 8*3]  ;;get old args num
add r9, 4
shl r9, 3             ;;set new r9 = (x+4)*8
;;fix the stack
SHIFT_FRAME 5    ;;args_count + 4 = n + env + ret addrs +old rbp
add rsp, r9            ;;set new stack pointer
pop rbp            ;;restore old rbp
jmp qword[rax + 1 + 8] ;;jmp to code (rax is all the closure, skip tag = +1, skip env = +8)

Lexit75:

leave
ret
Lcont73:

leave
ret
Lcont72:

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args
mov qword [fvar_tbl + 8*20], rax
mov rax, SOB_VOID_ADDRESS

leave
ret
Lcont69:

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

; LambdaSimple

MALLOC rbx, 24 ; rbx = pointer to ExtEnv
mov qword r8, [rbp + 8*2] ; r8 is a pointer to lexical env
; rbx[i+1] <- r8[i] using r9
mov rcx, 0 ; rcx is the loop var
mov rdx, 2
simple_ext_loop76:
mov r9, qword [r8 + 8*rcx]
mov qword [rbx + 8*(rcx+1)], r9
inc rcx
cmp rcx, rdx
jne simple_ext_loop76
mov r10, qword [rbp + 8 * 3] ; r10 is the number of params in previous env
mov r11, r10 ; save the amount of params
shl r10, 3 ; r10 = r10 * 8 - the real size that we should save
MALLOC rdx, r10
mov rcx, 0 ; rcx is the loop var, r11 is the limit, doing the exchange using r14
cmp r11, 0 ; there is no parameters
je simple_param_end_loop76
simple_param_loop76:
mov r14, PVAR(rcx)
mov qword [rdx + 8*(rcx)], r14
inc rcx
cmp rcx, r11
jne simple_param_loop76
simple_param_end_loop76:
mov qword [rbx], rdx ; put this env in ExtEnv[0]
MAKE_CLOSURE(rax, rbx, Lcode76)
jmp Lcont76
Lcode76:
push rbp
mov rbp, rsp
; LambdaOpt

MALLOC rbx, 32 ; rbx = pointer to ExtEnv
mov qword r8, [rbp + 8*2] ; r8 is a pointer to lexical env
; rbx[i+1] <- r8[i] using r9
mov rcx, 0 ; rcx is the loop var
mov rdx, 3
simple_ext_loop77:
mov r9, qword [r8 + 8*rcx]
mov qword [rbx + 8*(rcx+1)], r9
inc rcx
cmp rcx, rdx
jne simple_ext_loop77
mov r10, qword [rbp + 8 * 3] ; r10 is the number of params in previous env
mov r11, r10 ; save the amount of params
shl r10, 3 ; r10 = r10 * 8 - the real size that we should save
MALLOC rdx, r10
mov rcx, 0 ; rcx is the loop var, r11 is the limit, doing the exchange using r14
cmp r11, 0 ; there is no parameters
je simple_param_end_loop77
simple_param_loop77:
mov r14, PVAR(rcx)
mov qword [rdx + 8*(rcx)], r14
inc rcx
cmp rcx, r11
jne simple_param_loop77
simple_param_end_loop77:
mov qword [rbx], rdx ; put this env in ExtEnv[0]
MAKE_CLOSURE(rax, rbx, Lcode77)
jmp Lcont77
Lcode77:
; Adjust the stack for the optional arguments
mov rbx, qword [rsp + 8*2] ; rbx = actual_n
cmp rbx, 2
jne not_eq77
mov r8, qword [rsp + 8*(2 + rbx)]
mov r10, r8 ; r10 = address of element
MAKE_PAIR (r9, r10, SOB_NIL_ADDRESS) ; r9 = Pair(r10, Nil)
mov qword [rsp + 8*(2 + rbx)], r9 ; stack[n-1] = Pair(element, Nil)
jmp end_of_fix77
not_eq77:
; rbx have the actual n
cmp rbx, 2
jl enlarge_stack77
; new_n < old_n
; create list of rest element
mov rcx, rbx
sub rcx, 2
inc rcx ; Need to Pair the last element as well
mov r9, SOB_NIL_ADDRESS
pair_cons_loop77:
; rcx is the loop counter
; r8 = element from the end of stack to the position of the pair
mov r8, qword [rsp + 8*(2 + 2 + rcx - 1)]
MAKE_PAIR (rdx, r8, r9) ; rdx = Pair(r8, r9)
; update r9
mov r9, rdx
dec rcx
jnz pair_cons_loop77
; r9 has the list
mov qword [rsp + 8 * (2 + 2)], r9
; adjust the stack size from n to 2
mov r8, 2 ; r8 = new_n
add r8, 3 ; r8 = new_stack_size
; We want that rdx will point to the last element
mov rdx, r8
; We want that r10 will point to the last element of old stack
mov r8, rbx ; r8 = old_n
add r8, 3 ; r8 = old_stack_size
mov r10, r8
shift_stack_up77:
; stack[r10-1] <- stack[rdx-1] using r11
dec r10
dec rdx ; it is the smaller
mov r11, qword [rsp + 8*rdx]
mov qword [rsp + 8*r10], r11
jnz shift_stack_up77
; Fix rsp to point right
; r10 hold the diff between this two pointers
mul_small_stack_loop77:
add rsp, 8
dec r10
jnz mul_small_stack_loop77
jmp fix_n77
enlarge_stack77:
; old_n < new_n
; shift down the stack
mov r8, 2 ; r8 = new_n
add r8, 3 ; r8 = new_stack_size
mov rdx, r8 ; rdx = new_stack_size
mov r8, rbx ; r8 = old_n
add r8, 3 ; r8 = old_stack_size
mov r10, r8 ; r10 = old_stack_size
mov r9, 0
sub rsp, 8 ; we need to take down the hole stack
shift_stack_down77:
; stack[r9] <- stack[r9+1] using r11
mov r11, qword [rsp + 8*(r9+1)]
mov qword [rsp + 8*r9], r11
inc r9
dec r10 ; it is the smaller
jnz shift_stack_down77
; rsp is already fixed
; put in the cleared element NIL
mov qword [rsp + 8*(rdx - 1)], SOB_NIL_ADDRESS
fix_n77:
mov qword [rsp + 2*8], 2
end_of_fix77:
push rbp
mov rbp, rsp

; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

 push rax 
; LambdaSimple

MALLOC rbx, 40 ; rbx = pointer to ExtEnv
mov qword r8, [rbp + 8*2] ; r8 is a pointer to lexical env
; rbx[i+1] <- r8[i] using r9
mov rcx, 0 ; rcx is the loop var
mov rdx, 4
simple_ext_loop78:
mov r9, qword [r8 + 8*rcx]
mov qword [rbx + 8*(rcx+1)], r9
inc rcx
cmp rcx, rdx
jne simple_ext_loop78
mov r10, qword [rbp + 8 * 3] ; r10 is the number of params in previous env
mov r11, r10 ; save the amount of params
shl r10, 3 ; r10 = r10 * 8 - the real size that we should save
MALLOC rdx, r10
mov rcx, 0 ; rcx is the loop var, r11 is the limit, doing the exchange using r14
cmp r11, 0 ; there is no parameters
je simple_param_end_loop78
simple_param_loop78:
mov r14, PVAR(rcx)
mov qword [rdx + 8*(rcx)], r14
inc rcx
cmp rcx, r11
jne simple_param_loop78
simple_param_end_loop78:
mov qword [rbx], rdx ; put this env in ExtEnv[0]
MAKE_CLOSURE(rax, rbx, Lcode78)
jmp Lcont78
Lcode78:
push rbp
mov rbp, rsp

mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0]
mov rax, qword [rax + 8*0]

 push rax 

 push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*0]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
push qword[ rbp + 8 ] ;;old ret address)
push qword[rbp]    ;;backup old rbp
mov r9, qword[rbp + 8*3]  ;;get old args num
add r9, 4
shl r9, 3             ;;set new r9 = (x+4)*8
;;fix the stack
SHIFT_FRAME 6    ;;args_count + 4 = n + env + ret addrs +old rbp
add rsp, r9            ;;set new stack pointer
pop rbp            ;;restore old rbp
jmp qword[rax + 1 + 8] ;;jmp to code (rax is all the closure, skip tag = +1, skip env = +8)

leave
ret
Lcont78:

 push rax 

 push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*2]
mov rax, qword [rax + 8*4]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 

mov rax, const_tbl + 4

 push rax 
; LambdaSimple

MALLOC rbx, 40 ; rbx = pointer to ExtEnv
mov qword r8, [rbp + 8*2] ; r8 is a pointer to lexical env
; rbx[i+1] <- r8[i] using r9
mov rcx, 0 ; rcx is the loop var
mov rdx, 4
simple_ext_loop79:
mov r9, qword [r8 + 8*rcx]
mov qword [rbx + 8*(rcx+1)], r9
inc rcx
cmp rcx, rdx
jne simple_ext_loop79
mov r10, qword [rbp + 8 * 3] ; r10 is the number of params in previous env
mov r11, r10 ; save the amount of params
shl r10, 3 ; r10 = r10 * 8 - the real size that we should save
MALLOC rdx, r10
mov rcx, 0 ; rcx is the loop var, r11 is the limit, doing the exchange using r14
cmp r11, 0 ; there is no parameters
je simple_param_end_loop79
simple_param_loop79:
mov r14, PVAR(rcx)
mov qword [rdx + 8*(rcx)], r14
inc rcx
cmp rcx, r11
jne simple_param_loop79
simple_param_end_loop79:
mov qword [rbx], rdx ; put this env in ExtEnv[0]
MAKE_CLOSURE(rax, rbx, Lcode79)
jmp Lcont79
Lcode79:
push rbp
mov rbp, rsp

mov rax, qword [rbp + 8 * (4 + 0)]

cmp rax, SOB_FALSE_ADDRESS
je Lelse80
mov rax, qword [rbp + 8 * (4 + 1)]

jmp Lexit81
Lelse80:

mov rax, const_tbl + 2

Lexit81:

leave
ret
Lcont79:

 push rax 

 push 3
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*2]
mov rax, qword [rax + 8*3]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
push qword[ rbp + 8 ] ;;old ret address)
push qword[rbp]    ;;backup old rbp
mov r9, qword[rbp + 8*3]  ;;get old args num
add r9, 4
shl r9, 3             ;;set new r9 = (x+4)*8
;;fix the stack
SHIFT_FRAME 7    ;;args_count + 4 = n + env + ret addrs +old rbp
add rsp, r9            ;;set new stack pointer
pop rbp            ;;restore old rbp
jmp qword[rax + 1 + 8] ;;jmp to code (rax is all the closure, skip tag = +1, skip env = +8)

leave
ret
Lcont77:

leave
ret
Lcont76:

 push rax 

 push 1
; LambdaSimple

MALLOC rbx, 24 ; rbx = pointer to ExtEnv
mov qword r8, [rbp + 8*2] ; r8 is a pointer to lexical env
; rbx[i+1] <- r8[i] using r9
mov rcx, 0 ; rcx is the loop var
mov rdx, 2
simple_ext_loop82:
mov r9, qword [r8 + 8*rcx]
mov qword [rbx + 8*(rcx+1)], r9
inc rcx
cmp rcx, rdx
jne simple_ext_loop82
mov r10, qword [rbp + 8 * 3] ; r10 is the number of params in previous env
mov r11, r10 ; save the amount of params
shl r10, 3 ; r10 = r10 * 8 - the real size that we should save
MALLOC rdx, r10
mov rcx, 0 ; rcx is the loop var, r11 is the limit, doing the exchange using r14
cmp r11, 0 ; there is no parameters
je simple_param_end_loop82
simple_param_loop82:
mov r14, PVAR(rcx)
mov qword [rdx + 8*(rcx)], r14
inc rcx
cmp rcx, r11
jne simple_param_loop82
simple_param_end_loop82:
mov qword [rbx], rdx ; put this env in ExtEnv[0]
MAKE_CLOSURE(rax, rbx, Lcode82)
jmp Lcont82
Lcode82:
push rbp
mov rbp, rsp


; Applic

; Applic

mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*8]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0]
mov rax, qword [rax + 8*0]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 

 push 1
mov rax, qword [rbp + 8 * (4 + 0)]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args
mov qword [fvar_tbl + 8*21], rax
mov rax, SOB_VOID_ADDRESS

; Applic

; Applic

mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*9]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0]
mov rax, qword [rax + 8*0]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 

 push 1
mov rax, qword [rbp + 8 * (4 + 0)]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args
mov qword [fvar_tbl + 8*22], rax
mov rax, SOB_VOID_ADDRESS

leave
ret
Lcont82:

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
push qword[ rbp + 8 ] ;;old ret address)
push qword[rbp]    ;;backup old rbp
mov r9, qword[rbp + 8*3]  ;;get old args num
add r9, 4
shl r9, 3             ;;set new r9 = (x+4)*8
;;fix the stack
SHIFT_FRAME 5    ;;args_count + 4 = n + env + ret addrs +old rbp
add rsp, r9            ;;set new stack pointer
pop rbp            ;;restore old rbp
jmp qword[rax + 1 + 8] ;;jmp to code (rax is all the closure, skip tag = +1, skip env = +8)

leave
ret
Lcont64:

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
push qword[ rbp + 8 ] ;;old ret address)
push qword[rbp]    ;;backup old rbp
mov r9, qword[rbp + 8*3]  ;;get old args num
add r9, 4
shl r9, 3             ;;set new r9 = (x+4)*8
;;fix the stack
SHIFT_FRAME 5    ;;args_count + 4 = n + env + ret addrs +old rbp
add rsp, r9            ;;set new stack pointer
pop rbp            ;;restore old rbp
jmp qword[rax + 1 + 8] ;;jmp to code (rax is all the closure, skip tag = +1, skip env = +8)

leave
ret
Lcont53:

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

	call write_sob_if_not_void

; Applic

mov rax, qword [fvar_tbl + 8*4]

 push rax 
mov rax, qword [fvar_tbl + 8*18]

 push rax 
mov rax, qword [fvar_tbl + 8*29]

 push rax 

 push 3
; LambdaSimple

MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode83)
jmp Lcont83
Lcode83:
push rbp
mov rbp, rsp
; LambdaOpt

MALLOC rbx, 16 ; rbx = pointer to ExtEnv
mov qword r8, [rbp + 8*2] ; r8 is a pointer to lexical env
; rbx[i+1] <- r8[i] using r9
mov rcx, 0 ; rcx is the loop var
mov rdx, 1
simple_ext_loop84:
mov r9, qword [r8 + 8*rcx]
mov qword [rbx + 8*(rcx+1)], r9
inc rcx
cmp rcx, rdx
jne simple_ext_loop84
mov r10, qword [rbp + 8 * 3] ; r10 is the number of params in previous env
mov r11, r10 ; save the amount of params
shl r10, 3 ; r10 = r10 * 8 - the real size that we should save
MALLOC rdx, r10
mov rcx, 0 ; rcx is the loop var, r11 is the limit, doing the exchange using r14
cmp r11, 0 ; there is no parameters
je simple_param_end_loop84
simple_param_loop84:
mov r14, PVAR(rcx)
mov qword [rdx + 8*(rcx)], r14
inc rcx
cmp rcx, r11
jne simple_param_loop84
simple_param_end_loop84:
mov qword [rbx], rdx ; put this env in ExtEnv[0]
MAKE_CLOSURE(rax, rbx, Lcode84)
jmp Lcont84
Lcode84:
; Adjust the stack for the optional arguments
mov rbx, qword [rsp + 8*2] ; rbx = actual_n
cmp rbx, 2
jne not_eq84
mov r8, qword [rsp + 8*(2 + rbx)]
mov r10, r8 ; r10 = address of element
MAKE_PAIR (r9, r10, SOB_NIL_ADDRESS) ; r9 = Pair(r10, Nil)
mov qword [rsp + 8*(2 + rbx)], r9 ; stack[n-1] = Pair(element, Nil)
jmp end_of_fix84
not_eq84:
; rbx have the actual n
cmp rbx, 2
jl enlarge_stack84
; new_n < old_n
; create list of rest element
mov rcx, rbx
sub rcx, 2
inc rcx ; Need to Pair the last element as well
mov r9, SOB_NIL_ADDRESS
pair_cons_loop84:
; rcx is the loop counter
; r8 = element from the end of stack to the position of the pair
mov r8, qword [rsp + 8*(2 + 2 + rcx - 1)]
MAKE_PAIR (rdx, r8, r9) ; rdx = Pair(r8, r9)
; update r9
mov r9, rdx
dec rcx
jnz pair_cons_loop84
; r9 has the list
mov qword [rsp + 8 * (2 + 2)], r9
; adjust the stack size from n to 2
mov r8, 2 ; r8 = new_n
add r8, 3 ; r8 = new_stack_size
; We want that rdx will point to the last element
mov rdx, r8
; We want that r10 will point to the last element of old stack
mov r8, rbx ; r8 = old_n
add r8, 3 ; r8 = old_stack_size
mov r10, r8
shift_stack_up84:
; stack[r10-1] <- stack[rdx-1] using r11
dec r10
dec rdx ; it is the smaller
mov r11, qword [rsp + 8*rdx]
mov qword [rsp + 8*r10], r11
jnz shift_stack_up84
; Fix rsp to point right
; r10 hold the diff between this two pointers
mul_small_stack_loop84:
add rsp, 8
dec r10
jnz mul_small_stack_loop84
jmp fix_n84
enlarge_stack84:
; old_n < new_n
; shift down the stack
mov r8, 2 ; r8 = new_n
add r8, 3 ; r8 = new_stack_size
mov rdx, r8 ; rdx = new_stack_size
mov r8, rbx ; r8 = old_n
add r8, 3 ; r8 = old_stack_size
mov r10, r8 ; r10 = old_stack_size
mov r9, 0
sub rsp, 8 ; we need to take down the hole stack
shift_stack_down84:
; stack[r9] <- stack[r9+1] using r11
mov r11, qword [rsp + 8*(r9+1)]
mov qword [rsp + 8*r9], r11
inc r9
dec r10 ; it is the smaller
jnz shift_stack_down84
; rsp is already fixed
; put in the cleared element NIL
mov qword [rsp + 8*(rdx - 1)], SOB_NIL_ADDRESS
fix_n84:
mov qword [rsp + 2*8], 2
end_of_fix84:
push rbp
mov rbp, rsp

; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0]
mov rax, qword [rax + 8*2]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

cmp rax, SOB_FALSE_ADDRESS
je Lelse85

; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 

mov rax, const_tbl + 68

 push rax 

 push 2
mov rax, qword [fvar_tbl + 8*19]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 

mov rax, const_tbl + 51

 push rax 

 push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0]
mov rax, qword [rax + 8*1]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
push qword[ rbp + 8 ] ;;old ret address)
push qword[rbp]    ;;backup old rbp
mov r9, qword[rbp + 8*3]  ;;get old args num
add r9, 4
shl r9, 3             ;;set new r9 = (x+4)*8
;;fix the stack
SHIFT_FRAME 6    ;;args_count + 4 = n + env + ret addrs +old rbp
add rsp, r9            ;;set new stack pointer
pop rbp            ;;restore old rbp
jmp qword[rax + 1 + 8] ;;jmp to code (rax is all the closure, skip tag = +1, skip env = +8)

jmp Lexit86
Lelse85:

; Applic

; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

 push rax 
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0]
mov rax, qword [rax + 8*1]

 push rax 

 push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0]
mov rax, qword [rax + 8*0]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 

mov rax, const_tbl + 68

 push rax 

 push 2
mov rax, qword [fvar_tbl + 8*19]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 
mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 

 push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0]
mov rax, qword [rax + 8*1]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
push qword[ rbp + 8 ] ;;old ret address)
push qword[rbp]    ;;backup old rbp
mov r9, qword[rbp + 8*3]  ;;get old args num
add r9, 4
shl r9, 3             ;;set new r9 = (x+4)*8
;;fix the stack
SHIFT_FRAME 6    ;;args_count + 4 = n + env + ret addrs +old rbp
add rsp, r9            ;;set new stack pointer
pop rbp            ;;restore old rbp
jmp qword[rax + 1 + 8] ;;jmp to code (rax is all the closure, skip tag = +1, skip env = +8)

Lexit86:

leave
ret
Lcont84:

leave
ret
Lcont83:

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

mov qword [fvar_tbl + 8*42], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; Applic

mov rax, qword [fvar_tbl + 8*33]

 push rax 
mov rax, qword [fvar_tbl + 8*21]

 push rax 
mov rax, qword [fvar_tbl + 8*22]

 push rax 
mov rax, qword [fvar_tbl + 8*41]

 push rax 
mov rax, qword [fvar_tbl + 8*4]

 push rax 

 push 5
; LambdaSimple

MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode87)
jmp Lcont87
Lcode87:
push rbp
mov rbp, rsp
; LambdaOpt

MALLOC rbx, 16 ; rbx = pointer to ExtEnv
mov qword r8, [rbp + 8*2] ; r8 is a pointer to lexical env
; rbx[i+1] <- r8[i] using r9
mov rcx, 0 ; rcx is the loop var
mov rdx, 1
simple_ext_loop88:
mov r9, qword [r8 + 8*rcx]
mov qword [rbx + 8*(rcx+1)], r9
inc rcx
cmp rcx, rdx
jne simple_ext_loop88
mov r10, qword [rbp + 8 * 3] ; r10 is the number of params in previous env
mov r11, r10 ; save the amount of params
shl r10, 3 ; r10 = r10 * 8 - the real size that we should save
MALLOC rdx, r10
mov rcx, 0 ; rcx is the loop var, r11 is the limit, doing the exchange using r14
cmp r11, 0 ; there is no parameters
je simple_param_end_loop88
simple_param_loop88:
mov r14, PVAR(rcx)
mov qword [rdx + 8*(rcx)], r14
inc rcx
cmp rcx, r11
jne simple_param_loop88
simple_param_end_loop88:
mov qword [rbx], rdx ; put this env in ExtEnv[0]
MAKE_CLOSURE(rax, rbx, Lcode88)
jmp Lcont88
Lcode88:
; Adjust the stack for the optional arguments
mov rbx, qword [rsp + 8*2] ; rbx = actual_n
cmp rbx, 2
jne not_eq88
mov r8, qword [rsp + 8*(2 + rbx)]
mov r10, r8 ; r10 = address of element
MAKE_PAIR (r9, r10, SOB_NIL_ADDRESS) ; r9 = Pair(r10, Nil)
mov qword [rsp + 8*(2 + rbx)], r9 ; stack[n-1] = Pair(element, Nil)
jmp end_of_fix88
not_eq88:
; rbx have the actual n
cmp rbx, 2
jl enlarge_stack88
; new_n < old_n
; create list of rest element
mov rcx, rbx
sub rcx, 2
inc rcx ; Need to Pair the last element as well
mov r9, SOB_NIL_ADDRESS
pair_cons_loop88:
; rcx is the loop counter
; r8 = element from the end of stack to the position of the pair
mov r8, qword [rsp + 8*(2 + 2 + rcx - 1)]
MAKE_PAIR (rdx, r8, r9) ; rdx = Pair(r8, r9)
; update r9
mov r9, rdx
dec rcx
jnz pair_cons_loop88
; r9 has the list
mov qword [rsp + 8 * (2 + 2)], r9
; adjust the stack size from n to 2
mov r8, 2 ; r8 = new_n
add r8, 3 ; r8 = new_stack_size
; We want that rdx will point to the last element
mov rdx, r8
; We want that r10 will point to the last element of old stack
mov r8, rbx ; r8 = old_n
add r8, 3 ; r8 = old_stack_size
mov r10, r8
shift_stack_up88:
; stack[r10-1] <- stack[rdx-1] using r11
dec r10
dec rdx ; it is the smaller
mov r11, qword [rsp + 8*rdx]
mov qword [rsp + 8*r10], r11
jnz shift_stack_up88
; Fix rsp to point right
; r10 hold the diff between this two pointers
mul_small_stack_loop88:
add rsp, 8
dec r10
jnz mul_small_stack_loop88
jmp fix_n88
enlarge_stack88:
; old_n < new_n
; shift down the stack
mov r8, 2 ; r8 = new_n
add r8, 3 ; r8 = new_stack_size
mov rdx, r8 ; rdx = new_stack_size
mov r8, rbx ; r8 = old_n
add r8, 3 ; r8 = old_stack_size
mov r10, r8 ; r10 = old_stack_size
mov r9, 0
sub rsp, 8 ; we need to take down the hole stack
shift_stack_down88:
; stack[r9] <- stack[r9+1] using r11
mov r11, qword [rsp + 8*(r9+1)]
mov qword [rsp + 8*r9], r11
inc r9
dec r10 ; it is the smaller
jnz shift_stack_down88
; rsp is already fixed
; put in the cleared element NIL
mov qword [rsp + 8*(rdx - 1)], SOB_NIL_ADDRESS
fix_n88:
mov qword [rsp + 2*8], 2
end_of_fix88:
push rbp
mov rbp, rsp

mov rax, qword [rbp + 8 * (4 + 1)]

 push rax 

mov rax, const_tbl + 4

 push rax 
; LambdaSimple

MALLOC rbx, 24 ; rbx = pointer to ExtEnv
mov qword r8, [rbp + 8*2] ; r8 is a pointer to lexical env
; rbx[i+1] <- r8[i] using r9
mov rcx, 0 ; rcx is the loop var
mov rdx, 2
simple_ext_loop89:
mov r9, qword [r8 + 8*rcx]
mov qword [rbx + 8*(rcx+1)], r9
inc rcx
cmp rcx, rdx
jne simple_ext_loop89
mov r10, qword [rbp + 8 * 3] ; r10 is the number of params in previous env
mov r11, r10 ; save the amount of params
shl r10, 3 ; r10 = r10 * 8 - the real size that we should save
MALLOC rdx, r10
mov rcx, 0 ; rcx is the loop var, r11 is the limit, doing the exchange using r14
cmp r11, 0 ; there is no parameters
je simple_param_end_loop89
simple_param_loop89:
mov r14, PVAR(rcx)
mov qword [rdx + 8*(rcx)], r14
inc rcx
cmp rcx, r11
jne simple_param_loop89
simple_param_end_loop89:
mov qword [rbx], rdx ; put this env in ExtEnv[0]
MAKE_CLOSURE(rax, rbx, Lcode89)
jmp Lcont89
Lcode89:
push rbp
mov rbp, rsp

mov rax, qword [rbp + 8 * (4 + 0)]

cmp rax, SOB_FALSE_ADDRESS
je Lelse90


; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

 push rax 
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0]
mov rax, qword [rax + 8*0]

 push rax 

 push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*2]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

cmp rax, SOB_FALSE_ADDRESS
jne Lexit92
; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

 push rax 
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0]
mov rax, qword [rax + 8*0]

 push rax 

 push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*3]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

Lexit92:

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*1]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
push qword[ rbp + 8 ] ;;old ret address)
push qword[rbp]    ;;backup old rbp
mov r9, qword[rbp + 8*3]  ;;get old args num
add r9, 4
shl r9, 3             ;;set new r9 = (x+4)*8
;;fix the stack
SHIFT_FRAME 5    ;;args_count + 4 = n + env + ret addrs +old rbp
add rsp, r9            ;;set new stack pointer
pop rbp            ;;restore old rbp
jmp qword[rax + 1 + 8] ;;jmp to code (rax is all the closure, skip tag = +1, skip env = +8)

jmp Lexit91
Lelse90:

mov rax, const_tbl + 2

Lexit91:

leave
ret
Lcont89:

 push rax 

 push 3
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0]
mov rax, qword [rax + 8*4]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
push qword[ rbp + 8 ] ;;old ret address)
push qword[rbp]    ;;backup old rbp
mov r9, qword[rbp + 8*3]  ;;get old args num
add r9, 4
shl r9, 3             ;;set new r9 = (x+4)*8
;;fix the stack
SHIFT_FRAME 7    ;;args_count + 4 = n + env + ret addrs +old rbp
add rsp, r9            ;;set new stack pointer
pop rbp            ;;restore old rbp
jmp qword[rax + 1 + 8] ;;jmp to code (rax is all the closure, skip tag = +1, skip env = +8)

leave
ret
Lcont88:

leave
ret
Lcont87:

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

mov qword [fvar_tbl + 8*43], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; Applic

mov rax, qword [fvar_tbl + 8*27]

 push rax 
mov rax, qword [fvar_tbl + 8*26]

 push rax 
mov rax, qword [fvar_tbl + 8*4]

 push rax 
mov rax, qword [fvar_tbl + 8*25]

 push rax 

 push 4
; LambdaSimple

MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode93)
jmp Lcont93
Lcode93:
push rbp
mov rbp, rsp


mov rax, const_tbl + 23

 push rax 

 push 1
; LambdaSimple

MALLOC rbx, 16 ; rbx = pointer to ExtEnv
mov qword r8, [rbp + 8*2] ; r8 is a pointer to lexical env
; rbx[i+1] <- r8[i] using r9
mov rcx, 0 ; rcx is the loop var
mov rdx, 1
simple_ext_loop94:
mov r9, qword [r8 + 8*rcx]
mov qword [rbx + 8*(rcx+1)], r9
inc rcx
cmp rcx, rdx
jne simple_ext_loop94
mov r10, qword [rbp + 8 * 3] ; r10 is the number of params in previous env
mov r11, r10 ; save the amount of params
shl r10, 3 ; r10 = r10 * 8 - the real size that we should save
MALLOC rdx, r10
mov rcx, 0 ; rcx is the loop var, r11 is the limit, doing the exchange using r14
cmp r11, 0 ; there is no parameters
je simple_param_end_loop94
simple_param_loop94:
mov r14, PVAR(rcx)
mov qword [rdx + 8*(rcx)], r14
inc rcx
cmp rcx, r11
jne simple_param_loop94
simple_param_end_loop94:
mov qword [rbx], rdx ; put this env in ExtEnv[0]
MAKE_CLOSURE(rax, rbx, Lcode94)
jmp Lcont94
Lcode94:
push rbp
mov rbp, rsp



mov rax, qword [rbp + 8 * (4 + 0)]

MALLOC r8, 8
mov qword[r8], rax
mov rax, r8

mov qword [rbp + 8 * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS

; LambdaSimple

MALLOC rbx, 24 ; rbx = pointer to ExtEnv
mov qword r8, [rbp + 8*2] ; r8 is a pointer to lexical env
; rbx[i+1] <- r8[i] using r9
mov rcx, 0 ; rcx is the loop var
mov rdx, 2
simple_ext_loop95:
mov r9, qword [r8 + 8*rcx]
mov qword [rbx + 8*(rcx+1)], r9
inc rcx
cmp rcx, rdx
jne simple_ext_loop95
mov r10, qword [rbp + 8 * 3] ; r10 is the number of params in previous env
mov r11, r10 ; save the amount of params
shl r10, 3 ; r10 = r10 * 8 - the real size that we should save
MALLOC rdx, r10
mov rcx, 0 ; rcx is the loop var, r11 is the limit, doing the exchange using r14
cmp r11, 0 ; there is no parameters
je simple_param_end_loop95
simple_param_loop95:
mov r14, PVAR(rcx)
mov qword [rdx + 8*(rcx)], r14
inc rcx
cmp rcx, r11
jne simple_param_loop95
simple_param_end_loop95:
mov qword [rbx], rdx ; put this env in ExtEnv[0]
MAKE_CLOSURE(rax, rbx, Lcode95)
jmp Lcont95
Lcode95:
push rbp
mov rbp, rsp

; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*1]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

cmp rax, SOB_FALSE_ADDRESS
je Lelse96
mov rax, qword [rbp + 8 * (4 + 0)]

jmp Lexit97
Lelse96:

; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*3]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 
; Applic

; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*2]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 
mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 

 push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*0]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 

 push 2

mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0]
mov rax, qword [rax + 8*0]

mov rax, qword [rax]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
push qword[ rbp + 8 ] ;;old ret address)
push qword[rbp]    ;;backup old rbp
mov r9, qword[rbp + 8*3]  ;;get old args num
add r9, 4
shl r9, 3             ;;set new r9 = (x+4)*8
;;fix the stack
SHIFT_FRAME 6    ;;args_count + 4 = n + env + ret addrs +old rbp
add rsp, r9            ;;set new stack pointer
pop rbp            ;;restore old rbp
jmp qword[rax + 1 + 8] ;;jmp to code (rax is all the closure, skip tag = +1, skip env = +8)

Lexit97:

leave
ret
Lcont95:

push rax
mov rax, qword [rbp + 8 * (4 + 0)]

pop qword [rax]
mov rax, SOB_VOID_ADDRESS
; LambdaOpt

MALLOC rbx, 24 ; rbx = pointer to ExtEnv
mov qword r8, [rbp + 8*2] ; r8 is a pointer to lexical env
; rbx[i+1] <- r8[i] using r9
mov rcx, 0 ; rcx is the loop var
mov rdx, 2
simple_ext_loop98:
mov r9, qword [r8 + 8*rcx]
mov qword [rbx + 8*(rcx+1)], r9
inc rcx
cmp rcx, rdx
jne simple_ext_loop98
mov r10, qword [rbp + 8 * 3] ; r10 is the number of params in previous env
mov r11, r10 ; save the amount of params
shl r10, 3 ; r10 = r10 * 8 - the real size that we should save
MALLOC rdx, r10
mov rcx, 0 ; rcx is the loop var, r11 is the limit, doing the exchange using r14
cmp r11, 0 ; there is no parameters
je simple_param_end_loop98
simple_param_loop98:
mov r14, PVAR(rcx)
mov qword [rdx + 8*(rcx)], r14
inc rcx
cmp rcx, r11
jne simple_param_loop98
simple_param_end_loop98:
mov qword [rbx], rdx ; put this env in ExtEnv[0]
MAKE_CLOSURE(rax, rbx, Lcode98)
jmp Lcont98
Lcode98:
; Adjust the stack for the optional arguments
mov rbx, qword [rsp + 8*2] ; rbx = actual_n
cmp rbx, 1
jne not_eq98
mov r8, qword [rsp + 8*(2 + rbx)]
mov r10, r8 ; r10 = address of element
MAKE_PAIR (r9, r10, SOB_NIL_ADDRESS) ; r9 = Pair(r10, Nil)
mov qword [rsp + 8*(2 + rbx)], r9 ; stack[n-1] = Pair(element, Nil)
jmp end_of_fix98
not_eq98:
; rbx have the actual n
cmp rbx, 1
jl enlarge_stack98
; new_n < old_n
; create list of rest element
mov rcx, rbx
sub rcx, 1
inc rcx ; Need to Pair the last element as well
mov r9, SOB_NIL_ADDRESS
pair_cons_loop98:
; rcx is the loop counter
; r8 = element from the end of stack to the position of the pair
mov r8, qword [rsp + 8*(2 + 1 + rcx - 1)]
MAKE_PAIR (rdx, r8, r9) ; rdx = Pair(r8, r9)
; update r9
mov r9, rdx
dec rcx
jnz pair_cons_loop98
; r9 has the list
mov qword [rsp + 8 * (2 + 1)], r9
; adjust the stack size from n to 1
mov r8, 1 ; r8 = new_n
add r8, 3 ; r8 = new_stack_size
; We want that rdx will point to the last element
mov rdx, r8
; We want that r10 will point to the last element of old stack
mov r8, rbx ; r8 = old_n
add r8, 3 ; r8 = old_stack_size
mov r10, r8
shift_stack_up98:
; stack[r10-1] <- stack[rdx-1] using r11
dec r10
dec rdx ; it is the smaller
mov r11, qword [rsp + 8*rdx]
mov qword [rsp + 8*r10], r11
jnz shift_stack_up98
; Fix rsp to point right
; r10 hold the diff between this two pointers
mul_small_stack_loop98:
add rsp, 8
dec r10
jnz mul_small_stack_loop98
jmp fix_n98
enlarge_stack98:
; old_n < new_n
; shift down the stack
mov r8, 1 ; r8 = new_n
add r8, 3 ; r8 = new_stack_size
mov rdx, r8 ; rdx = new_stack_size
mov r8, rbx ; r8 = old_n
add r8, 3 ; r8 = old_stack_size
mov r10, r8 ; r10 = old_stack_size
mov r9, 0
sub rsp, 8 ; we need to take down the hole stack
shift_stack_down98:
; stack[r9] <- stack[r9+1] using r11
mov r11, qword [rsp + 8*(r9+1)]
mov qword [rsp + 8*r9], r11
inc r9
dec r10 ; it is the smaller
jnz shift_stack_down98
; rsp is already fixed
; put in the cleared element NIL
mov qword [rsp + 8*(rdx - 1)], SOB_NIL_ADDRESS
fix_n98:
mov qword [rsp + 2*8], 1
end_of_fix98:
push rbp
mov rbp, rsp

; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*1]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

cmp rax, SOB_FALSE_ADDRESS
je Lelse99

mov rax, const_tbl + 51

jmp Lexit100
Lelse99:

; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*3]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 
; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*2]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 

 push 2

mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0]
mov rax, qword [rax + 8*0]

mov rax, qword [rax]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
push qword[ rbp + 8 ] ;;old ret address)
push qword[rbp]    ;;backup old rbp
mov r9, qword[rbp + 8*3]  ;;get old args num
add r9, 4
shl r9, 3             ;;set new r9 = (x+4)*8
;;fix the stack
SHIFT_FRAME 6    ;;args_count + 4 = n + env + ret addrs +old rbp
add rsp, r9            ;;set new stack pointer
pop rbp            ;;restore old rbp
jmp qword[rax + 1 + 8] ;;jmp to code (rax is all the closure, skip tag = +1, skip env = +8)

Lexit100:

leave
ret
Lcont98:

leave
ret
Lcont94:

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
push qword[ rbp + 8 ] ;;old ret address)
push qword[rbp]    ;;backup old rbp
mov r9, qword[rbp + 8*3]  ;;get old args num
add r9, 4
shl r9, 3             ;;set new r9 = (x+4)*8
;;fix the stack
SHIFT_FRAME 5    ;;args_count + 4 = n + env + ret addrs +old rbp
add rsp, r9            ;;set new stack pointer
pop rbp            ;;restore old rbp
jmp qword[rax + 1 + 8] ;;jmp to code (rax is all the closure, skip tag = +1, skip env = +8)

leave
ret
Lcont93:

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

mov qword [fvar_tbl + 8*25], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; Applic

mov rax, qword [fvar_tbl + 8*21]

 push rax 

 push 1
; LambdaSimple

MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode101)
jmp Lcont101
Lcode101:
push rbp
mov rbp, rsp
; LambdaSimple

MALLOC rbx, 16 ; rbx = pointer to ExtEnv
mov qword r8, [rbp + 8*2] ; r8 is a pointer to lexical env
; rbx[i+1] <- r8[i] using r9
mov rcx, 0 ; rcx is the loop var
mov rdx, 1
simple_ext_loop102:
mov r9, qword [r8 + 8*rcx]
mov qword [rbx + 8*(rcx+1)], r9
inc rcx
cmp rcx, rdx
jne simple_ext_loop102
mov r10, qword [rbp + 8 * 3] ; r10 is the number of params in previous env
mov r11, r10 ; save the amount of params
shl r10, 3 ; r10 = r10 * 8 - the real size that we should save
MALLOC rdx, r10
mov rcx, 0 ; rcx is the loop var, r11 is the limit, doing the exchange using r14
cmp r11, 0 ; there is no parameters
je simple_param_end_loop102
simple_param_loop102:
mov r14, PVAR(rcx)
mov qword [rdx + 8*(rcx)], r14
inc rcx
cmp rcx, r11
jne simple_param_loop102
simple_param_end_loop102:
mov qword [rbx], rdx ; put this env in ExtEnv[0]
MAKE_CLOSURE(rax, rbx, Lcode102)
jmp Lcont102
Lcode102:
push rbp
mov rbp, rsp


mov rax, const_tbl + 51

 push rax 
mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 

 push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0]
mov rax, qword [rax + 8*0]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
push qword[ rbp + 8 ] ;;old ret address)
push qword[rbp]    ;;backup old rbp
mov r9, qword[rbp + 8*3]  ;;get old args num
add r9, 4
shl r9, 3             ;;set new r9 = (x+4)*8
;;fix the stack
SHIFT_FRAME 6    ;;args_count + 4 = n + env + ret addrs +old rbp
add rsp, r9            ;;set new stack pointer
pop rbp            ;;restore old rbp
jmp qword[rax + 1 + 8] ;;jmp to code (rax is all the closure, skip tag = +1, skip env = +8)

leave
ret
Lcont102:

leave
ret
Lcont101:

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

mov qword [fvar_tbl + 8*44], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; Applic

mov rax, qword [fvar_tbl + 8*24]

 push rax 
mov rax, qword [fvar_tbl + 8*21]

 push rax 
mov rax, qword [fvar_tbl + 8*2]

 push rax 

 push 3
; LambdaSimple

MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode103)
jmp Lcont103
Lcode103:
push rbp
mov rbp, rsp
; LambdaSimple

MALLOC rbx, 16 ; rbx = pointer to ExtEnv
mov qword r8, [rbp + 8*2] ; r8 is a pointer to lexical env
; rbx[i+1] <- r8[i] using r9
mov rcx, 0 ; rcx is the loop var
mov rdx, 1
simple_ext_loop104:
mov r9, qword [r8 + 8*rcx]
mov qword [rbx + 8*(rcx+1)], r9
inc rcx
cmp rcx, rdx
jne simple_ext_loop104
mov r10, qword [rbp + 8 * 3] ; r10 is the number of params in previous env
mov r11, r10 ; save the amount of params
shl r10, 3 ; r10 = r10 * 8 - the real size that we should save
MALLOC rdx, r10
mov rcx, 0 ; rcx is the loop var, r11 is the limit, doing the exchange using r14
cmp r11, 0 ; there is no parameters
je simple_param_end_loop104
simple_param_loop104:
mov r14, PVAR(rcx)
mov qword [rdx + 8*(rcx)], r14
inc rcx
cmp rcx, r11
jne simple_param_loop104
simple_param_end_loop104:
mov qword [rbx], rdx ; put this env in ExtEnv[0]
MAKE_CLOSURE(rax, rbx, Lcode104)
jmp Lcont104
Lcode104:
push rbp
mov rbp, rsp

; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0]
mov rax, qword [rax + 8*0]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

cmp rax, SOB_FALSE_ADDRESS
je Lelse105


mov rax, const_tbl + 32

 push rax 
; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0]
mov rax, qword [rax + 8*2]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 

 push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0]
mov rax, qword [rax + 8*1]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
push qword[ rbp + 8 ] ;;old ret address)
push qword[rbp]    ;;backup old rbp
mov r9, qword[rbp + 8*3]  ;;get old args num
add r9, 4
shl r9, 3             ;;set new r9 = (x+4)*8
;;fix the stack
SHIFT_FRAME 6    ;;args_count + 4 = n + env + ret addrs +old rbp
add rsp, r9            ;;set new stack pointer
pop rbp            ;;restore old rbp
jmp qword[rax + 1 + 8] ;;jmp to code (rax is all the closure, skip tag = +1, skip env = +8)

jmp Lexit106
Lelse105:

mov rax, const_tbl + 2

Lexit106:

leave
ret
Lcont104:

leave
ret
Lcont103:

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

mov qword [fvar_tbl + 8*45], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; Applic

mov rax, qword [fvar_tbl + 8*2]

 push rax 
mov rax, qword [fvar_tbl + 8*1]

 push rax 

 push 2
; LambdaSimple

MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode107)
jmp Lcont107
Lcode107:
push rbp
mov rbp, rsp
; LambdaSimple

MALLOC rbx, 16 ; rbx = pointer to ExtEnv
mov qword r8, [rbp + 8*2] ; r8 is a pointer to lexical env
; rbx[i+1] <- r8[i] using r9
mov rcx, 0 ; rcx is the loop var
mov rdx, 1
simple_ext_loop108:
mov r9, qword [r8 + 8*rcx]
mov qword [rbx + 8*(rcx+1)], r9
inc rcx
cmp rcx, rdx
jne simple_ext_loop108
mov r10, qword [rbp + 8 * 3] ; r10 is the number of params in previous env
mov r11, r10 ; save the amount of params
shl r10, 3 ; r10 = r10 * 8 - the real size that we should save
MALLOC rdx, r10
mov rcx, 0 ; rcx is the loop var, r11 is the limit, doing the exchange using r14
cmp r11, 0 ; there is no parameters
je simple_param_end_loop108
simple_param_loop108:
mov r14, PVAR(rcx)
mov qword [rdx + 8*(rcx)], r14
inc rcx
cmp rcx, r11
jne simple_param_loop108
simple_param_end_loop108:
mov qword [rbx], rdx ; put this env in ExtEnv[0]
MAKE_CLOSURE(rax, rbx, Lcode108)
jmp Lcont108
Lcode108:
push rbp
mov rbp, rsp

; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0]
mov rax, qword [rax + 8*0]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

cmp rax, SOB_FALSE_ADDRESS
jne Lexit109

mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0]
mov rax, qword [rax + 8*1]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
push qword[ rbp + 8 ] ;;old ret address)
push qword[rbp]    ;;backup old rbp
mov r9, qword[rbp + 8*3]  ;;get old args num
add r9, 4
shl r9, 3             ;;set new r9 = (x+4)*8
;;fix the stack
SHIFT_FRAME 5    ;;args_count + 4 = n + env + ret addrs +old rbp
add rsp, r9            ;;set new stack pointer
pop rbp            ;;restore old rbp
jmp qword[rax + 1 + 8] ;;jmp to code (rax is all the closure, skip tag = +1, skip env = +8)

Lexit109:

leave
ret
Lcont108:

leave
ret
Lcont107:

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

mov qword [fvar_tbl + 8*46], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; Applic

mov rax, qword [fvar_tbl + 8*18]

 push rax 
mov rax, qword [fvar_tbl + 8*33]

 push rax 

 push 2
; LambdaSimple

MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode110)
jmp Lcont110
Lcode110:
push rbp
mov rbp, rsp
; LambdaSimple

MALLOC rbx, 16 ; rbx = pointer to ExtEnv
mov qword r8, [rbp + 8*2] ; r8 is a pointer to lexical env
; rbx[i+1] <- r8[i] using r9
mov rcx, 0 ; rcx is the loop var
mov rdx, 1
simple_ext_loop111:
mov r9, qword [r8 + 8*rcx]
mov qword [rbx + 8*(rcx+1)], r9
inc rcx
cmp rcx, rdx
jne simple_ext_loop111
mov r10, qword [rbp + 8 * 3] ; r10 is the number of params in previous env
mov r11, r10 ; save the amount of params
shl r10, 3 ; r10 = r10 * 8 - the real size that we should save
MALLOC rdx, r10
mov rcx, 0 ; rcx is the loop var, r11 is the limit, doing the exchange using r14
cmp r11, 0 ; there is no parameters
je simple_param_end_loop111
simple_param_loop111:
mov r14, PVAR(rcx)
mov qword [rdx + 8*(rcx)], r14
inc rcx
cmp rcx, r11
jne simple_param_loop111
simple_param_end_loop111:
mov qword [rbx], rdx ; put this env in ExtEnv[0]
MAKE_CLOSURE(rax, rbx, Lcode111)
jmp Lcont111
Lcode111:
push rbp
mov rbp, rsp

mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 

mov rax, const_tbl + 51

 push rax 
; LambdaSimple

MALLOC rbx, 24 ; rbx = pointer to ExtEnv
mov qword r8, [rbp + 8*2] ; r8 is a pointer to lexical env
; rbx[i+1] <- r8[i] using r9
mov rcx, 0 ; rcx is the loop var
mov rdx, 2
simple_ext_loop112:
mov r9, qword [r8 + 8*rcx]
mov qword [rbx + 8*(rcx+1)], r9
inc rcx
cmp rcx, rdx
jne simple_ext_loop112
mov r10, qword [rbp + 8 * 3] ; r10 is the number of params in previous env
mov r11, r10 ; save the amount of params
shl r10, 3 ; r10 = r10 * 8 - the real size that we should save
MALLOC rdx, r10
mov rcx, 0 ; rcx is the loop var, r11 is the limit, doing the exchange using r14
cmp r11, 0 ; there is no parameters
je simple_param_end_loop112
simple_param_loop112:
mov r14, PVAR(rcx)
mov qword [rdx + 8*(rcx)], r14
inc rcx
cmp rcx, r11
jne simple_param_loop112
simple_param_end_loop112:
mov qword [rbx], rdx ; put this env in ExtEnv[0]
MAKE_CLOSURE(rax, rbx, Lcode112)
jmp Lcont112
Lcode112:
push rbp
mov rbp, rsp


mov rax, const_tbl + 32

 push rax 
mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 

 push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*1]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
push qword[ rbp + 8 ] ;;old ret address)
push qword[rbp]    ;;backup old rbp
mov r9, qword[rbp + 8*3]  ;;get old args num
add r9, 4
shl r9, 3             ;;set new r9 = (x+4)*8
;;fix the stack
SHIFT_FRAME 6    ;;args_count + 4 = n + env + ret addrs +old rbp
add rsp, r9            ;;set new stack pointer
pop rbp            ;;restore old rbp
jmp qword[rax + 1 + 8] ;;jmp to code (rax is all the closure, skip tag = +1, skip env = +8)

leave
ret
Lcont112:

 push rax 

 push 3
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0]
mov rax, qword [rax + 8*0]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
push qword[ rbp + 8 ] ;;old ret address)
push qword[rbp]    ;;backup old rbp
mov r9, qword[rbp + 8*3]  ;;get old args num
add r9, 4
shl r9, 3             ;;set new r9 = (x+4)*8
;;fix the stack
SHIFT_FRAME 7    ;;args_count + 4 = n + env + ret addrs +old rbp
add rsp, r9            ;;set new stack pointer
pop rbp            ;;restore old rbp
jmp qword[rax + 1 + 8] ;;jmp to code (rax is all the closure, skip tag = +1, skip env = +8)

leave
ret
Lcont111:

leave
ret
Lcont110:

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

mov qword [fvar_tbl + 8*47], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; Applic

mov rax, qword [fvar_tbl + 8*28]

 push rax 
mov rax, qword [fvar_tbl + 8*42]

 push rax 
mov rax, qword [fvar_tbl + 8*22]

 push rax 
mov rax, qword [fvar_tbl + 8*9]

 push rax 
mov rax, qword [fvar_tbl + 8*10]

 push rax 

 push 5
; LambdaSimple

MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode113)
jmp Lcont113
Lcode113:
push rbp
mov rbp, rsp
; LambdaSimple

MALLOC rbx, 16 ; rbx = pointer to ExtEnv
mov qword r8, [rbp + 8*2] ; r8 is a pointer to lexical env
; rbx[i+1] <- r8[i] using r9
mov rcx, 0 ; rcx is the loop var
mov rdx, 1
simple_ext_loop114:
mov r9, qword [r8 + 8*rcx]
mov qword [rbx + 8*(rcx+1)], r9
inc rcx
cmp rcx, rdx
jne simple_ext_loop114
mov r10, qword [rbp + 8 * 3] ; r10 is the number of params in previous env
mov r11, r10 ; save the amount of params
shl r10, 3 ; r10 = r10 * 8 - the real size that we should save
MALLOC rdx, r10
mov rcx, 0 ; rcx is the loop var, r11 is the limit, doing the exchange using r14
cmp r11, 0 ; there is no parameters
je simple_param_end_loop114
simple_param_loop114:
mov r14, PVAR(rcx)
mov qword [rdx + 8*(rcx)], r14
inc rcx
cmp rcx, r11
jne simple_param_loop114
simple_param_end_loop114:
mov qword [rbx], rdx ; put this env in ExtEnv[0]
MAKE_CLOSURE(rax, rbx, Lcode114)
jmp Lcont114
Lcode114:
push rbp
mov rbp, rsp


mov rax, const_tbl + 23

 push rax 

 push 1
; LambdaSimple

MALLOC rbx, 24 ; rbx = pointer to ExtEnv
mov qword r8, [rbp + 8*2] ; r8 is a pointer to lexical env
; rbx[i+1] <- r8[i] using r9
mov rcx, 0 ; rcx is the loop var
mov rdx, 2
simple_ext_loop115:
mov r9, qword [r8 + 8*rcx]
mov qword [rbx + 8*(rcx+1)], r9
inc rcx
cmp rcx, rdx
jne simple_ext_loop115
mov r10, qword [rbp + 8 * 3] ; r10 is the number of params in previous env
mov r11, r10 ; save the amount of params
shl r10, 3 ; r10 = r10 * 8 - the real size that we should save
MALLOC rdx, r10
mov rcx, 0 ; rcx is the loop var, r11 is the limit, doing the exchange using r14
cmp r11, 0 ; there is no parameters
je simple_param_end_loop115
simple_param_loop115:
mov r14, PVAR(rcx)
mov qword [rdx + 8*(rcx)], r14
inc rcx
cmp rcx, r11
jne simple_param_loop115
simple_param_end_loop115:
mov qword [rbx], rdx ; put this env in ExtEnv[0]
MAKE_CLOSURE(rax, rbx, Lcode115)
jmp Lcont115
Lcode115:
push rbp
mov rbp, rsp



mov rax, qword [rbp + 8 * (4 + 0)]

MALLOC r8, 8
mov qword[r8], rax
mov rax, r8

mov qword [rbp + 8 * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS

; LambdaSimple

MALLOC rbx, 32 ; rbx = pointer to ExtEnv
mov qword r8, [rbp + 8*2] ; r8 is a pointer to lexical env
; rbx[i+1] <- r8[i] using r9
mov rcx, 0 ; rcx is the loop var
mov rdx, 3
simple_ext_loop116:
mov r9, qword [r8 + 8*rcx]
mov qword [rbx + 8*(rcx+1)], r9
inc rcx
cmp rcx, rdx
jne simple_ext_loop116
mov r10, qword [rbp + 8 * 3] ; r10 is the number of params in previous env
mov r11, r10 ; save the amount of params
shl r10, 3 ; r10 = r10 * 8 - the real size that we should save
MALLOC rdx, r10
mov rcx, 0 ; rcx is the loop var, r11 is the limit, doing the exchange using r14
cmp r11, 0 ; there is no parameters
je simple_param_end_loop116
simple_param_loop116:
mov r14, PVAR(rcx)
mov qword [rdx + 8*(rcx)], r14
inc rcx
cmp rcx, r11
jne simple_param_loop116
simple_param_end_loop116:
mov qword [rbx], rdx ; put this env in ExtEnv[0]
MAKE_CLOSURE(rax, rbx, Lcode116)
jmp Lcont116
Lcode116:
push rbp
mov rbp, rsp

; Applic


mov rax, const_tbl + 51

 push rax 
mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 

 push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*2]
mov rax, qword [rax + 8*2]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

cmp rax, SOB_FALSE_ADDRESS
je Lelse117
mov rax, qword [rbp + 8 * (4 + 1)]

jmp Lexit118
Lelse117:

; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

 push rax 
; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*0]

 push rax 

 push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*2]
mov rax, qword [rax + 8*0]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 

 push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*2]
mov rax, qword [rax + 8*4]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 
; Applic


mov rax, const_tbl + 32

 push rax 
mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 

 push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*2]
mov rax, qword [rax + 8*3]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 

 push 2

mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0]
mov rax, qword [rax + 8*0]

mov rax, qword [rax]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
push qword[ rbp + 8 ] ;;old ret address)
push qword[rbp]    ;;backup old rbp
mov r9, qword[rbp + 8*3]  ;;get old args num
add r9, 4
shl r9, 3             ;;set new r9 = (x+4)*8
;;fix the stack
SHIFT_FRAME 6    ;;args_count + 4 = n + env + ret addrs +old rbp
add rsp, r9            ;;set new stack pointer
pop rbp            ;;restore old rbp
jmp qword[rax + 1 + 8] ;;jmp to code (rax is all the closure, skip tag = +1, skip env = +8)

Lexit118:

leave
ret
Lcont116:

push rax
mov rax, qword [rbp + 8 * (4 + 0)]

pop qword [rax]
mov rax, SOB_VOID_ADDRESS


mov rax, const_tbl + 1

 push rax 
; Applic


mov rax, const_tbl + 32

 push rax 
; Applic

mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0]
mov rax, qword [rax + 8*0]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*1]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 

 push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*3]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 

 push 2

mov rax, qword [rbp + 8 * (4 + 0)]

mov rax, qword [rax]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
push qword[ rbp + 8 ] ;;old ret address)
push qword[rbp]    ;;backup old rbp
mov r9, qword[rbp + 8*3]  ;;get old args num
add r9, 4
shl r9, 3             ;;set new r9 = (x+4)*8
;;fix the stack
SHIFT_FRAME 6    ;;args_count + 4 = n + env + ret addrs +old rbp
add rsp, r9            ;;set new stack pointer
pop rbp            ;;restore old rbp
jmp qword[rax + 1 + 8] ;;jmp to code (rax is all the closure, skip tag = +1, skip env = +8)

leave
ret
Lcont115:

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
push qword[ rbp + 8 ] ;;old ret address)
push qword[rbp]    ;;backup old rbp
mov r9, qword[rbp + 8*3]  ;;get old args num
add r9, 4
shl r9, 3             ;;set new r9 = (x+4)*8
;;fix the stack
SHIFT_FRAME 5    ;;args_count + 4 = n + env + ret addrs +old rbp
add rsp, r9            ;;set new stack pointer
pop rbp            ;;restore old rbp
jmp qword[rax + 1 + 8] ;;jmp to code (rax is all the closure, skip tag = +1, skip env = +8)

leave
ret
Lcont114:

leave
ret
Lcont113:

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

mov qword [fvar_tbl + 8*48], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; Applic

mov rax, qword [fvar_tbl + 8*14]

 push rax 
mov rax, qword [fvar_tbl + 8*27]

 push rax 
mov rax, qword [fvar_tbl + 8*26]

 push rax 
mov rax, qword [fvar_tbl + 8*17]

 push rax 
mov rax, qword [fvar_tbl + 8*6]

 push rax 
mov rax, qword [fvar_tbl + 8*5]

 push rax 
mov rax, qword [fvar_tbl + 8*3]

 push rax 
mov rax, qword [fvar_tbl + 8*1]

 push rax 
mov rax, qword [fvar_tbl + 8*2]

 push rax 
mov rax, qword [fvar_tbl + 8*48]

 push rax 
mov rax, qword [fvar_tbl + 8*21]

 push rax 

 push 11
; LambdaSimple

MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode119)
jmp Lcont119
Lcode119:
push rbp
mov rbp, rsp


mov rax, const_tbl + 23

 push rax 

 push 1
; LambdaSimple

MALLOC rbx, 16 ; rbx = pointer to ExtEnv
mov qword r8, [rbp + 8*2] ; r8 is a pointer to lexical env
; rbx[i+1] <- r8[i] using r9
mov rcx, 0 ; rcx is the loop var
mov rdx, 1
simple_ext_loop120:
mov r9, qword [r8 + 8*rcx]
mov qword [rbx + 8*(rcx+1)], r9
inc rcx
cmp rcx, rdx
jne simple_ext_loop120
mov r10, qword [rbp + 8 * 3] ; r10 is the number of params in previous env
mov r11, r10 ; save the amount of params
shl r10, 3 ; r10 = r10 * 8 - the real size that we should save
MALLOC rdx, r10
mov rcx, 0 ; rcx is the loop var, r11 is the limit, doing the exchange using r14
cmp r11, 0 ; there is no parameters
je simple_param_end_loop120
simple_param_loop120:
mov r14, PVAR(rcx)
mov qword [rdx + 8*(rcx)], r14
inc rcx
cmp rcx, r11
jne simple_param_loop120
simple_param_end_loop120:
mov qword [rbx], rdx ; put this env in ExtEnv[0]
MAKE_CLOSURE(rax, rbx, Lcode120)
jmp Lcont120
Lcode120:
push rbp
mov rbp, rsp



mov rax, qword [rbp + 8 * (4 + 0)]

MALLOC r8, 8
mov qword[r8], rax
mov rax, r8

mov qword [rbp + 8 * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS

; LambdaSimple

MALLOC rbx, 24 ; rbx = pointer to ExtEnv
mov qword r8, [rbp + 8*2] ; r8 is a pointer to lexical env
; rbx[i+1] <- r8[i] using r9
mov rcx, 0 ; rcx is the loop var
mov rdx, 2
simple_ext_loop121:
mov r9, qword [r8 + 8*rcx]
mov qword [rbx + 8*(rcx+1)], r9
inc rcx
cmp rcx, rdx
jne simple_ext_loop121
mov r10, qword [rbp + 8 * 3] ; r10 is the number of params in previous env
mov r11, r10 ; save the amount of params
shl r10, 3 ; r10 = r10 * 8 - the real size that we should save
MALLOC rdx, r10
mov rcx, 0 ; rcx is the loop var, r11 is the limit, doing the exchange using r14
cmp r11, 0 ; there is no parameters
je simple_param_end_loop121
simple_param_loop121:
mov r14, PVAR(rcx)
mov qword [rdx + 8*(rcx)], r14
inc rcx
cmp rcx, r11
jne simple_param_loop121
simple_param_end_loop121:
mov qword [rbx], rdx ; put this env in ExtEnv[0]
MAKE_CLOSURE(rax, rbx, Lcode121)
jmp Lcont121
Lcode121:
push rbp
mov rbp, rsp


; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*2]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

cmp rax, SOB_FALSE_ADDRESS
je Lelse142
; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*2]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

jmp Lexit143
Lelse142:

mov rax, const_tbl + 2

Lexit143:

cmp rax, SOB_FALSE_ADDRESS
je Lelse122

mov rax, qword [rbp + 8 * (4 + 1)]

 push rax 
mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 

 push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*0]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
push qword[ rbp + 8 ] ;;old ret address)
push qword[rbp]    ;;backup old rbp
mov r9, qword[rbp + 8*3]  ;;get old args num
add r9, 4
shl r9, 3             ;;set new r9 = (x+4)*8
;;fix the stack
SHIFT_FRAME 6    ;;args_count + 4 = n + env + ret addrs +old rbp
add rsp, r9            ;;set new stack pointer
pop rbp            ;;restore old rbp
jmp qword[rax + 1 + 8] ;;jmp to code (rax is all the closure, skip tag = +1, skip env = +8)

jmp Lexit123
Lelse122:


; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*3]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

cmp rax, SOB_FALSE_ADDRESS
je Lelse140
; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*3]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

jmp Lexit141
Lelse140:

mov rax, const_tbl + 2

Lexit141:

cmp rax, SOB_FALSE_ADDRESS
je Lelse124

mov rax, qword [rbp + 8 * (4 + 1)]

 push rax 
mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 

 push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*0]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
push qword[ rbp + 8 ] ;;old ret address)
push qword[rbp]    ;;backup old rbp
mov r9, qword[rbp + 8*3]  ;;get old args num
add r9, 4
shl r9, 3             ;;set new r9 = (x+4)*8
;;fix the stack
SHIFT_FRAME 6    ;;args_count + 4 = n + env + ret addrs +old rbp
add rsp, r9            ;;set new stack pointer
pop rbp            ;;restore old rbp
jmp qword[rax + 1 + 8] ;;jmp to code (rax is all the closure, skip tag = +1, skip env = +8)

jmp Lexit125
Lelse124:


; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*5]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

cmp rax, SOB_FALSE_ADDRESS
je Lelse138
; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*5]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

jmp Lexit139
Lelse138:

mov rax, const_tbl + 2

Lexit139:

cmp rax, SOB_FALSE_ADDRESS
je Lelse126

; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*10]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 
; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*10]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 

 push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*0]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
push qword[ rbp + 8 ] ;;old ret address)
push qword[rbp]    ;;backup old rbp
mov r9, qword[rbp + 8*3]  ;;get old args num
add r9, 4
shl r9, 3             ;;set new r9 = (x+4)*8
;;fix the stack
SHIFT_FRAME 6    ;;args_count + 4 = n + env + ret addrs +old rbp
add rsp, r9            ;;set new stack pointer
pop rbp            ;;restore old rbp
jmp qword[rax + 1 + 8] ;;jmp to code (rax is all the closure, skip tag = +1, skip env = +8)

jmp Lexit127
Lelse126:


; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*4]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

cmp rax, SOB_FALSE_ADDRESS
je Lelse136
; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*4]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

jmp Lexit137
Lelse136:

mov rax, const_tbl + 2

Lexit137:

cmp rax, SOB_FALSE_ADDRESS
je Lelse128

; Applic

; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*8]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 
; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*8]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 

 push 2

mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0]
mov rax, qword [rax + 8*0]

mov rax, qword [rax]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

cmp rax, SOB_FALSE_ADDRESS
je Lelse134

; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*9]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 
; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*9]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 

 push 2

mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0]
mov rax, qword [rax + 8*0]

mov rax, qword [rax]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
push qword[ rbp + 8 ] ;;old ret address)
push qword[rbp]    ;;backup old rbp
mov r9, qword[rbp + 8*3]  ;;get old args num
add r9, 4
shl r9, 3             ;;set new r9 = (x+4)*8
;;fix the stack
SHIFT_FRAME 6    ;;args_count + 4 = n + env + ret addrs +old rbp
add rsp, r9            ;;set new stack pointer
pop rbp            ;;restore old rbp
jmp qword[rax + 1 + 8] ;;jmp to code (rax is all the closure, skip tag = +1, skip env = +8)

jmp Lexit135
Lelse134:

mov rax, const_tbl + 2

Lexit135:

jmp Lexit129
Lelse128:


; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*6]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

cmp rax, SOB_FALSE_ADDRESS
je Lelse132
; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*6]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

jmp Lexit133
Lelse132:

mov rax, const_tbl + 2

Lexit133:

cmp rax, SOB_FALSE_ADDRESS
je Lelse130

; Applic

mov rax, qword [rbp + 8 * (4 + 1)]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*1]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 
; Applic

mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 

 push 1
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*1]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

 push rax 

 push 2

mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*0]
mov rax, qword [rax + 8*0]

mov rax, qword [rax]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
push qword[ rbp + 8 ] ;;old ret address)
push qword[rbp]    ;;backup old rbp
mov r9, qword[rbp + 8*3]  ;;get old args num
add r9, 4
shl r9, 3             ;;set new r9 = (x+4)*8
;;fix the stack
SHIFT_FRAME 6    ;;args_count + 4 = n + env + ret addrs +old rbp
add rsp, r9            ;;set new stack pointer
pop rbp            ;;restore old rbp
jmp qword[rax + 1 + 8] ;;jmp to code (rax is all the closure, skip tag = +1, skip env = +8)

jmp Lexit131
Lelse130:

mov rax, qword [rbp + 8 * (4 + 1)]

 push rax 
mov rax, qword [rbp + 8 * (4 + 0)]

 push rax 

 push 2
mov rax, qword [rbp + 8*2]
mov rax, qword [rax + 8*1]
mov rax, qword [rax + 8*7]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
push qword[ rbp + 8 ] ;;old ret address)
push qword[rbp]    ;;backup old rbp
mov r9, qword[rbp + 8*3]  ;;get old args num
add r9, 4
shl r9, 3             ;;set new r9 = (x+4)*8
;;fix the stack
SHIFT_FRAME 6    ;;args_count + 4 = n + env + ret addrs +old rbp
add rsp, r9            ;;set new stack pointer
pop rbp            ;;restore old rbp
jmp qword[rax + 1 + 8] ;;jmp to code (rax is all the closure, skip tag = +1, skip env = +8)

Lexit131:

Lexit129:

Lexit127:

Lexit125:

Lexit123:

leave
ret
Lcont121:

push rax
mov rax, qword [rbp + 8 * (4 + 0)]

pop qword [rax]
mov rax, SOB_VOID_ADDRESS

mov rax, qword [rbp + 8 * (4 + 0)]

mov rax, qword [rax]

leave
ret
Lcont120:

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
push qword[ rbp + 8 ] ;;old ret address)
push qword[rbp]    ;;backup old rbp
mov r9, qword[rbp + 8*3]  ;;get old args num
add r9, 4
shl r9, 3             ;;set new r9 = (x+4)*8
;;fix the stack
SHIFT_FRAME 5    ;;args_count + 4 = n + env + ret addrs +old rbp
add rsp, r9            ;;set new stack pointer
pop rbp            ;;restore old rbp
jmp qword[rax + 1 + 8] ;;jmp to code (rax is all the closure, skip tag = +1, skip env = +8)

leave
ret
Lcont119:

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

mov qword [fvar_tbl + 8*49], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; Applic


mov rax, const_tbl + 102

 push rax 

mov rax, const_tbl + 85

 push rax 

 push 2
mov rax, qword [fvar_tbl + 8*12]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

mov qword [fvar_tbl + 8*50], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; Applic


mov rax, const_tbl + 104

 push rax 

mov rax, const_tbl + 51

 push rax 
mov rax, qword [fvar_tbl + 8*50]

 push rax 

 push 3
mov rax, qword [fvar_tbl + 8*11]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

	call write_sob_if_not_void

; Applic


mov rax, const_tbl + 106

 push rax 

mov rax, const_tbl + 32

 push rax 
mov rax, qword [fvar_tbl + 8*50]

 push rax 

 push 3
mov rax, qword [fvar_tbl + 8*11]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

	call write_sob_if_not_void

; Applic


mov rax, const_tbl + 125

 push rax 

mov rax, const_tbl + 108

 push rax 
mov rax, qword [fvar_tbl + 8*50]

 push rax 

 push 3
mov rax, qword [fvar_tbl + 8*11]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

	call write_sob_if_not_void

; Applic


mov rax, const_tbl + 144

 push rax 

mov rax, const_tbl + 127

 push rax 
mov rax, qword [fvar_tbl + 8*50]

 push rax 

 push 3
mov rax, qword [fvar_tbl + 8*11]

push qword[ rax + 1 ] ;;push env (rax is all the closure, skip tag = +1)
call qword[ rax + 1 + 8 ] ;;call code (rax is all the closure, skip tag = +1, skip env = +8)
add rsp, 8 ;;pop env
pop rbx ;;pop arg count
shl rbx, 3 ;;rbx = rbx*8
add rsp, rbx ;;pop args

	call write_sob_if_not_void

mov rax, qword [fvar_tbl + 8*50]

	call write_sob_if_not_void;;; Clean up the dummy frame, set the exit status to 0 ("success"), 
   ;;; and return from main
   pop rbp
   add rsp, 3*8
   mov rax, 0

   ret
boolean?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_BOOL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

flonum?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_FLOAT
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

rational?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_RATIONAL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

pair?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_PAIR
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

null?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_NIL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

char?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_CHAR
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

string?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_STRING
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

symbol?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_SYMBOL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

procedure?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_CLOSURE
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

div:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .div_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  divsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .div_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          MAKE_RATIONAL(rax, rdx, rdi)
         mov PVAR(1), rax
         pop rbp
         jmp mul
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
         pop rbp
         ret

mul:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .mul_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  mulsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .mul_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          imul rsi, rdi
	 imul rcx, rdx
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
         pop rbp
         ret

add:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .add_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  addsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .add_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          imul rsi, rdx
	 imul rdi, rcx
	 add rsi, rdi
	 imul rcx, rdx
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
         pop rbp
         ret

eq:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .eq_rat
             FLOAT_VAL rsi, rsi
	 FLOAT_VAL rdi, rdi
	 cmp rsi, rdi
             jmp .op_return
          .eq_rat:
             NUMERATOR rcx, rsi
	 NUMERATOR rdx, rdi
	 cmp rcx, rdx
	 jne .false
	 DENOMINATOR rcx, rsi
	 DENOMINATOR rdx, rdi
	 cmp rcx, rdx
         .false:
          .op_return:
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

lt:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .lt_rat
             FLOAT_VAL rsi, rsi
	 movq xmm0, rsi
	 FLOAT_VAL rdi, rdi
	 movq xmm1, rdi
	 ucomisd xmm0, xmm1
             jmp .op_return
          .lt_rat:
             DENOMINATOR rcx, rsi
	 DENOMINATOR rdx, rdi
	 NUMERATOR rsi, rsi
	 NUMERATOR rdi, rdi
	 imul rsi, rdx
	 imul rdi, rcx
	 cmp rsi, rdi
          .op_return:
      jl .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

string_length:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	STRING_LENGTH rsi, rsi
         MAKE_RATIONAL(rax, rsi, 1)
         pop rbp
         ret

string_ref:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	STRING_ELEMENTS rsi, rsi
         NUMERATOR rdi, rdi
         add rsi, rdi
         mov sil, byte [rsi]
         MAKE_CHAR(rax, sil)
         pop rbp
         ret

string_set:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov rdx, PVAR(2)
	STRING_ELEMENTS rsi, rsi
         NUMERATOR rdi, rdi
         add rsi, rdi
         CHAR_VAL rax, rdx
         mov byte [rsi], al
         mov rax, SOB_VOID_ADDRESS
         pop rbp
         ret

make_string:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	NUMERATOR rsi, rsi
         CHAR_VAL rdi, rdi
         and rdi, 255
         MAKE_STRING rax, rsi, dil
         pop rbp
         ret

symbol_to_string:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	SYMBOL_VAL rsi, rsi
	 STRING_LENGTH rcx, rsi
	 STRING_ELEMENTS rdi, rsi
	 push rcx
	 push rdi
	 mov dil, byte [rdi]
	 MAKE_CHAR(rax, dil)
	 push rax
	 MAKE_RATIONAL(rax, rcx, 1)
	 push rax
	 push 2
	 push SOB_NIL_ADDRESS
	 call make_string
	 add rsp, 4*8
	 STRING_ELEMENTS rsi, rax   
	 pop rdi
	 pop rcx
	 cmp rcx, 0
	 je .end
         .loop:
	 lea r8, [rdi+rcx]
	 lea r9, [rsi+rcx]
	 mov bl, byte [r8]
	 mov byte [r9], bl
	 loop .loop
         .end:
         pop rbp
         ret

eq?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	cmp rsi, rdi
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

char_to_integer:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	CHAR_VAL rsi, rsi
	 and rsi, 255
	 MAKE_RATIONAL(rax, rsi, 1)
         pop rbp
         ret

integer_to_char:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	NUMERATOR rsi, rsi
	 and rsi, 255
	 MAKE_CHAR(rax, sil)
         pop rbp
         ret

exact_to_inexact:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	DENOMINATOR rdi, rsi
	 NUMERATOR rsi, rsi 
	 cvtsi2sd xmm0, rsi
	 cvtsi2sd xmm1, rdi
	 divsd xmm0, xmm1
	 movq rsi, xmm0
	 MAKE_FLOAT(rax, rsi)
         pop rbp
         ret

numerator:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	NUMERATOR rsi, rsi
	 mov rdi, 1
	 MAKE_RATIONAL(rax, rsi, rdi)
         pop rbp
         ret

denominator:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	DENOMINATOR rsi, rsi
	 mov rdi, 1
	 MAKE_RATIONAL(rax, rsi, rdi)
         pop rbp
         ret

gcd:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	xor rdx, rdx
	 NUMERATOR rax, rsi
         NUMERATOR rdi, rdi
       .loop:
	 and rdi, rdi
	 jz .end_loop
	 xor rdx, rdx 
	 div rdi
	 mov rax, rdi
	 mov rdi, rdx
	 jmp .loop	
       .end_loop:
	 mov rdx, rax
         MAKE_RATIONAL(rax, rdx, 1)
         pop rbp
         ret

car:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	CAR rax, rsi
         pop rbp
         ret

cdr:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	CDR rax, rsi
         pop rbp
         ret

setcar:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov qword [rsi+TYPE_SIZE], rdi
 mov rax, SOB_VOID_ADDRESS
         pop rbp
         ret

setcdr:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov qword [rsi+TYPE_SIZE+WORD_SIZE], rdi
 mov rax, SOB_VOID_ADDRESS
         pop rbp
         ret

cons:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	MAKE_PAIR(rax, rsi, rdi)
         pop rbp
         ret

apply:
push rbp
mov rbp, rsp
mov r8, 0 ; counter of arguments in list
mov r9, qword [rbp + 8*3] ; r9 have the number of args
dec r9 ; we want the position of the last arg (the list)
mov rbx, PVAR(r9)
; now we going to push the list args to the stack
apply_push_list:
cmp rbx, SOB_NIL_ADDRESS
je apply_end_of_push_list
CAR rdx, rbx ; rdx = car(lst)
CDR rbx, rbx ; rbx = cdr(lst)
push rdx
inc r8
jmp apply_push_list
apply_end_of_push_list:
; we need to swap so the last arg will be the uppest
mov r9, 0
mov r10, r8 ; the amount of args in list
dec r10 ; starting from n-1
; swap stack[r9] with stack[r10] using r11 and r12 (cause cannot mov mem to mem)
apply_swap_list_args:
cmp r9, r10
jge apply_end_of_swap_list_args
mov r11, qword [rsp + 8*r9]
mov r12, qword [rsp + 8*r10]
mov qword [rsp + 8*r9], r12
mov qword [rsp + 8*r10], r11
inc r9
dec r10
jmp apply_swap_list_args
apply_end_of_swap_list_args:
; now we going to push all of the rest args, from the end to the beginning
mov r9, qword [rbp + 8*3] ; r9 have the number of args, rsp still point the stack when calls
sub r9, 2 ; 1 for list and 1 for proc
mov r10, r9 ; save the number of args
apply_push_args:
cmp r9, 0
je apply_end_of_push_args
push PVAR(r9) ; starting from the end, dont want to push the proc in PVAR(0)
dec r9
jmp apply_push_args
apply_end_of_push_args:
; we should push the rest of frame (n, env, return address and old rbp)
; r10 have the number of arguments not in list, and r8 have the number in list
mov r9, r10 ; r9 will hold the new n
add r9, r8
mov rbx, r9 ; save the new n
push r9 ; push new n
; to push the env we need to take it out from closure
mov rax, qword [rbp + 8*4] ; rax = closure of proc
CLOSURE_ENV r9, rax
push r9 ; push new env
push qword [rbp + 8*1] ; push return address
push qword [rbp] ; push old rsp
mov rdx, qword [rbp] ; save old rbp
add r10, 6 ; r10 holds the number of args in old frame, adding 2 for proc and list and 4 for the rest frame
; r10 = old frame size
mov r9, rbx ; r9 is the new n
add r9, 4 ; r9 = size of new frame
mov r11, r10 ; save r10
; shift the stack upward
mov rcx, r9 ; rcx is the counter
apply_shift_stack:
; doing the shift using r8
; rcx is the pointer to the new frame, and r10 is the pointer to new position
dec r10
dec rcx
mov r8, qword [rsp + 8*rcx]
mov qword [rbp + 8*r10], r8
cmp rcx, 0 ; r9 times times
jne apply_shift_stack
shl r11, 3 ; r11 is the real size of shift
add rsp, r11 ; fix rsp
pop rbp ; restore old rbp
jmp qword [rax + 1 + 8]; jmp to code in tail call, 1 for type and 8 for env